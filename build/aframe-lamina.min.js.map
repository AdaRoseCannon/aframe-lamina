{"version":3,"file":"aframe-lamina.min.js","sources":["../node_modules/glsl-tokenizer/lib/literals.js","../node_modules/glsl-tokenizer/lib/operators.js","../node_modules/glsl-tokenizer/lib/builtins.js","../node_modules/glsl-tokenizer/lib/literals-300es.js","../node_modules/glsl-tokenizer/lib/builtins-300es.js","../node_modules/glsl-tokenizer/index.js","../node_modules/glsl-tokenizer/string.js","../node_modules/glsl-token-depth/index.js","../node_modules/glsl-token-scope/index.js","../node_modules/glsl-token-properties/index.js","../node_modules/glsl-token-assignments/assignments.js","../node_modules/glsl-token-assignments/ignored.js","../node_modules/glsl-token-assignments/index.js","../node_modules/glsl-token-descope/index.js","../node_modules/glsl-token-string/index.js","../node_modules/glsl-token-functions/index.js","../node_modules/three-custom-shader-material/vanilla.js","../node_modules/lamina/vanilla.js","../src/aframe-lamina.js"],"sourcesContent":["module.exports = [\r\n  // current\r\n    'precision'\r\n  , 'highp'\r\n  , 'mediump'\r\n  , 'lowp'\r\n  , 'attribute'\r\n  , 'const'\r\n  , 'uniform'\r\n  , 'varying'\r\n  , 'break'\r\n  , 'continue'\r\n  , 'do'\r\n  , 'for'\r\n  , 'while'\r\n  , 'if'\r\n  , 'else'\r\n  , 'in'\r\n  , 'out'\r\n  , 'inout'\r\n  , 'float'\r\n  , 'int'\r\n  , 'uint'\r\n  , 'void'\r\n  , 'bool'\r\n  , 'true'\r\n  , 'false'\r\n  , 'discard'\r\n  , 'return'\r\n  , 'mat2'\r\n  , 'mat3'\r\n  , 'mat4'\r\n  , 'vec2'\r\n  , 'vec3'\r\n  , 'vec4'\r\n  , 'ivec2'\r\n  , 'ivec3'\r\n  , 'ivec4'\r\n  , 'bvec2'\r\n  , 'bvec3'\r\n  , 'bvec4'\r\n  , 'sampler1D'\r\n  , 'sampler2D'\r\n  , 'sampler3D'\r\n  , 'samplerCube'\r\n  , 'sampler1DShadow'\r\n  , 'sampler2DShadow'\r\n  , 'struct'\r\n\r\n  // future\r\n  , 'asm'\r\n  , 'class'\r\n  , 'union'\r\n  , 'enum'\r\n  , 'typedef'\r\n  , 'template'\r\n  , 'this'\r\n  , 'packed'\r\n  , 'goto'\r\n  , 'switch'\r\n  , 'default'\r\n  , 'inline'\r\n  , 'noinline'\r\n  , 'volatile'\r\n  , 'public'\r\n  , 'static'\r\n  , 'extern'\r\n  , 'external'\r\n  , 'interface'\r\n  , 'long'\r\n  , 'short'\r\n  , 'double'\r\n  , 'half'\r\n  , 'fixed'\r\n  , 'unsigned'\r\n  , 'input'\r\n  , 'output'\r\n  , 'hvec2'\r\n  , 'hvec3'\r\n  , 'hvec4'\r\n  , 'dvec2'\r\n  , 'dvec3'\r\n  , 'dvec4'\r\n  , 'fvec2'\r\n  , 'fvec3'\r\n  , 'fvec4'\r\n  , 'sampler2DRect'\r\n  , 'sampler3DRect'\r\n  , 'sampler2DRectShadow'\r\n  , 'sizeof'\r\n  , 'cast'\r\n  , 'namespace'\r\n  , 'using'\r\n]\r\n","module.exports = [\r\n    '<<='\r\n  , '>>='\r\n  , '++'\r\n  , '--'\r\n  , '<<'\r\n  , '>>'\r\n  , '<='\r\n  , '>='\r\n  , '=='\r\n  , '!='\r\n  , '&&'\r\n  , '||'\r\n  , '+='\r\n  , '-='\r\n  , '*='\r\n  , '/='\r\n  , '%='\r\n  , '&='\r\n  , '^^'\r\n  , '^='\r\n  , '|='\r\n  , '('\r\n  , ')'\r\n  , '['\r\n  , ']'\r\n  , '.'\r\n  , '!'\r\n  , '~'\r\n  , '*'\r\n  , '/'\r\n  , '%'\r\n  , '+'\r\n  , '-'\r\n  , '<'\r\n  , '>'\r\n  , '&'\r\n  , '^'\r\n  , '|'\r\n  , '?'\r\n  , ':'\r\n  , '='\r\n  , ','\r\n  , ';'\r\n  , '{'\r\n  , '}'\r\n]\r\n","module.exports = [\r\n  // Keep this list sorted\r\n  'abs'\r\n  , 'acos'\r\n  , 'all'\r\n  , 'any'\r\n  , 'asin'\r\n  , 'atan'\r\n  , 'ceil'\r\n  , 'clamp'\r\n  , 'cos'\r\n  , 'cross'\r\n  , 'dFdx'\r\n  , 'dFdy'\r\n  , 'degrees'\r\n  , 'distance'\r\n  , 'dot'\r\n  , 'equal'\r\n  , 'exp'\r\n  , 'exp2'\r\n  , 'faceforward'\r\n  , 'floor'\r\n  , 'fract'\r\n  , 'gl_BackColor'\r\n  , 'gl_BackLightModelProduct'\r\n  , 'gl_BackLightProduct'\r\n  , 'gl_BackMaterial'\r\n  , 'gl_BackSecondaryColor'\r\n  , 'gl_ClipPlane'\r\n  , 'gl_ClipVertex'\r\n  , 'gl_Color'\r\n  , 'gl_DepthRange'\r\n  , 'gl_DepthRangeParameters'\r\n  , 'gl_EyePlaneQ'\r\n  , 'gl_EyePlaneR'\r\n  , 'gl_EyePlaneS'\r\n  , 'gl_EyePlaneT'\r\n  , 'gl_Fog'\r\n  , 'gl_FogCoord'\r\n  , 'gl_FogFragCoord'\r\n  , 'gl_FogParameters'\r\n  , 'gl_FragColor'\r\n  , 'gl_FragCoord'\r\n  , 'gl_FragData'\r\n  , 'gl_FragDepth'\r\n  , 'gl_FragDepthEXT'\r\n  , 'gl_FrontColor'\r\n  , 'gl_FrontFacing'\r\n  , 'gl_FrontLightModelProduct'\r\n  , 'gl_FrontLightProduct'\r\n  , 'gl_FrontMaterial'\r\n  , 'gl_FrontSecondaryColor'\r\n  , 'gl_LightModel'\r\n  , 'gl_LightModelParameters'\r\n  , 'gl_LightModelProducts'\r\n  , 'gl_LightProducts'\r\n  , 'gl_LightSource'\r\n  , 'gl_LightSourceParameters'\r\n  , 'gl_MaterialParameters'\r\n  , 'gl_MaxClipPlanes'\r\n  , 'gl_MaxCombinedTextureImageUnits'\r\n  , 'gl_MaxDrawBuffers'\r\n  , 'gl_MaxFragmentUniformComponents'\r\n  , 'gl_MaxLights'\r\n  , 'gl_MaxTextureCoords'\r\n  , 'gl_MaxTextureImageUnits'\r\n  , 'gl_MaxTextureUnits'\r\n  , 'gl_MaxVaryingFloats'\r\n  , 'gl_MaxVertexAttribs'\r\n  , 'gl_MaxVertexTextureImageUnits'\r\n  , 'gl_MaxVertexUniformComponents'\r\n  , 'gl_ModelViewMatrix'\r\n  , 'gl_ModelViewMatrixInverse'\r\n  , 'gl_ModelViewMatrixInverseTranspose'\r\n  , 'gl_ModelViewMatrixTranspose'\r\n  , 'gl_ModelViewProjectionMatrix'\r\n  , 'gl_ModelViewProjectionMatrixInverse'\r\n  , 'gl_ModelViewProjectionMatrixInverseTranspose'\r\n  , 'gl_ModelViewProjectionMatrixTranspose'\r\n  , 'gl_MultiTexCoord0'\r\n  , 'gl_MultiTexCoord1'\r\n  , 'gl_MultiTexCoord2'\r\n  , 'gl_MultiTexCoord3'\r\n  , 'gl_MultiTexCoord4'\r\n  , 'gl_MultiTexCoord5'\r\n  , 'gl_MultiTexCoord6'\r\n  , 'gl_MultiTexCoord7'\r\n  , 'gl_Normal'\r\n  , 'gl_NormalMatrix'\r\n  , 'gl_NormalScale'\r\n  , 'gl_ObjectPlaneQ'\r\n  , 'gl_ObjectPlaneR'\r\n  , 'gl_ObjectPlaneS'\r\n  , 'gl_ObjectPlaneT'\r\n  , 'gl_Point'\r\n  , 'gl_PointCoord'\r\n  , 'gl_PointParameters'\r\n  , 'gl_PointSize'\r\n  , 'gl_Position'\r\n  , 'gl_ProjectionMatrix'\r\n  , 'gl_ProjectionMatrixInverse'\r\n  , 'gl_ProjectionMatrixInverseTranspose'\r\n  , 'gl_ProjectionMatrixTranspose'\r\n  , 'gl_SecondaryColor'\r\n  , 'gl_TexCoord'\r\n  , 'gl_TextureEnvColor'\r\n  , 'gl_TextureMatrix'\r\n  , 'gl_TextureMatrixInverse'\r\n  , 'gl_TextureMatrixInverseTranspose'\r\n  , 'gl_TextureMatrixTranspose'\r\n  , 'gl_Vertex'\r\n  , 'greaterThan'\r\n  , 'greaterThanEqual'\r\n  , 'inversesqrt'\r\n  , 'length'\r\n  , 'lessThan'\r\n  , 'lessThanEqual'\r\n  , 'log'\r\n  , 'log2'\r\n  , 'matrixCompMult'\r\n  , 'max'\r\n  , 'min'\r\n  , 'mix'\r\n  , 'mod'\r\n  , 'normalize'\r\n  , 'not'\r\n  , 'notEqual'\r\n  , 'pow'\r\n  , 'radians'\r\n  , 'reflect'\r\n  , 'refract'\r\n  , 'sign'\r\n  , 'sin'\r\n  , 'smoothstep'\r\n  , 'sqrt'\r\n  , 'step'\r\n  , 'tan'\r\n  , 'texture2D'\r\n  , 'texture2DLod'\r\n  , 'texture2DProj'\r\n  , 'texture2DProjLod'\r\n  , 'textureCube'\r\n  , 'textureCubeLod'\r\n  , 'texture2DLodEXT'\r\n  , 'texture2DProjLodEXT'\r\n  , 'textureCubeLodEXT'\r\n  , 'texture2DGradEXT'\r\n  , 'texture2DProjGradEXT'\r\n  , 'textureCubeGradEXT'\r\n]\r\n","var v100 = require('./literals')\r\n\r\nmodule.exports = v100.slice().concat([\r\n   'layout'\r\n  , 'centroid'\r\n  , 'smooth'\r\n  , 'case'\r\n  , 'mat2x2'\r\n  , 'mat2x3'\r\n  , 'mat2x4'\r\n  , 'mat3x2'\r\n  , 'mat3x3'\r\n  , 'mat3x4'\r\n  , 'mat4x2'\r\n  , 'mat4x3'\r\n  , 'mat4x4'\r\n  , 'uvec2'\r\n  , 'uvec3'\r\n  , 'uvec4'\r\n  , 'samplerCubeShadow'\r\n  , 'sampler2DArray'\r\n  , 'sampler2DArrayShadow'\r\n  , 'isampler2D'\r\n  , 'isampler3D'\r\n  , 'isamplerCube'\r\n  , 'isampler2DArray'\r\n  , 'usampler2D'\r\n  , 'usampler3D'\r\n  , 'usamplerCube'\r\n  , 'usampler2DArray'\r\n  , 'coherent'\r\n  , 'restrict'\r\n  , 'readonly'\r\n  , 'writeonly'\r\n  , 'resource'\r\n  , 'atomic_uint'\r\n  , 'noperspective'\r\n  , 'patch'\r\n  , 'sample'\r\n  , 'subroutine'\r\n  , 'common'\r\n  , 'partition'\r\n  , 'active'\r\n  , 'filter'\r\n  , 'image1D'\r\n  , 'image2D'\r\n  , 'image3D'\r\n  , 'imageCube'\r\n  , 'iimage1D'\r\n  , 'iimage2D'\r\n  , 'iimage3D'\r\n  , 'iimageCube'\r\n  , 'uimage1D'\r\n  , 'uimage2D'\r\n  , 'uimage3D'\r\n  , 'uimageCube'\r\n  , 'image1DArray'\r\n  , 'image2DArray'\r\n  , 'iimage1DArray'\r\n  , 'iimage2DArray'\r\n  , 'uimage1DArray'\r\n  , 'uimage2DArray'\r\n  , 'image1DShadow'\r\n  , 'image2DShadow'\r\n  , 'image1DArrayShadow'\r\n  , 'image2DArrayShadow'\r\n  , 'imageBuffer'\r\n  , 'iimageBuffer'\r\n  , 'uimageBuffer'\r\n  , 'sampler1DArray'\r\n  , 'sampler1DArrayShadow'\r\n  , 'isampler1D'\r\n  , 'isampler1DArray'\r\n  , 'usampler1D'\r\n  , 'usampler1DArray'\r\n  , 'isampler2DRect'\r\n  , 'usampler2DRect'\r\n  , 'samplerBuffer'\r\n  , 'isamplerBuffer'\r\n  , 'usamplerBuffer'\r\n  , 'sampler2DMS'\r\n  , 'isampler2DMS'\r\n  , 'usampler2DMS'\r\n  , 'sampler2DMSArray'\r\n  , 'isampler2DMSArray'\r\n  , 'usampler2DMSArray'\r\n])\r\n","// 300es builtins/reserved words that were previously valid in v100\r\nvar v100 = require('./builtins')\r\n\r\n// The texture2D|Cube functions have been removed\r\n// And the gl_ features are updated\r\nv100 = v100.slice().filter(function (b) {\r\n  return !/^(gl\\_|texture)/.test(b)\r\n})\r\n\r\nmodule.exports = v100.concat([\r\n  // the updated gl_ constants\r\n    'gl_VertexID'\r\n  , 'gl_InstanceID'\r\n  , 'gl_Position'\r\n  , 'gl_PointSize'\r\n  , 'gl_FragCoord'\r\n  , 'gl_FrontFacing'\r\n  , 'gl_FragDepth'\r\n  , 'gl_PointCoord'\r\n  , 'gl_MaxVertexAttribs'\r\n  , 'gl_MaxVertexUniformVectors'\r\n  , 'gl_MaxVertexOutputVectors'\r\n  , 'gl_MaxFragmentInputVectors'\r\n  , 'gl_MaxVertexTextureImageUnits'\r\n  , 'gl_MaxCombinedTextureImageUnits'\r\n  , 'gl_MaxTextureImageUnits'\r\n  , 'gl_MaxFragmentUniformVectors'\r\n  , 'gl_MaxDrawBuffers'\r\n  , 'gl_MinProgramTexelOffset'\r\n  , 'gl_MaxProgramTexelOffset'\r\n  , 'gl_DepthRangeParameters'\r\n  , 'gl_DepthRange'\r\n\r\n  // other builtins\r\n  , 'trunc'\r\n  , 'round'\r\n  , 'roundEven'\r\n  , 'isnan'\r\n  , 'isinf'\r\n  , 'floatBitsToInt'\r\n  , 'floatBitsToUint'\r\n  , 'intBitsToFloat'\r\n  , 'uintBitsToFloat'\r\n  , 'packSnorm2x16'\r\n  , 'unpackSnorm2x16'\r\n  , 'packUnorm2x16'\r\n  , 'unpackUnorm2x16'\r\n  , 'packHalf2x16'\r\n  , 'unpackHalf2x16'\r\n  , 'outerProduct'\r\n  , 'transpose'\r\n  , 'determinant'\r\n  , 'inverse'\r\n  , 'texture'\r\n  , 'textureSize'\r\n  , 'textureProj'\r\n  , 'textureLod'\r\n  , 'textureOffset'\r\n  , 'texelFetch'\r\n  , 'texelFetchOffset'\r\n  , 'textureProjOffset'\r\n  , 'textureLodOffset'\r\n  , 'textureProjLod'\r\n  , 'textureProjLodOffset'\r\n  , 'textureGrad'\r\n  , 'textureGradOffset'\r\n  , 'textureProjGrad'\r\n  , 'textureProjGradOffset'\r\n])\r\n","module.exports = tokenize\r\n\r\nvar literals100 = require('./lib/literals')\r\n  , operators = require('./lib/operators')\r\n  , builtins100 = require('./lib/builtins')\r\n  , literals300es = require('./lib/literals-300es')\r\n  , builtins300es = require('./lib/builtins-300es')\r\n\r\nvar NORMAL = 999          // <-- never emitted\r\n  , TOKEN = 9999          // <-- never emitted\r\n  , BLOCK_COMMENT = 0\r\n  , LINE_COMMENT = 1\r\n  , PREPROCESSOR = 2\r\n  , OPERATOR = 3\r\n  , INTEGER = 4\r\n  , FLOAT = 5\r\n  , IDENT = 6\r\n  , BUILTIN = 7\r\n  , KEYWORD = 8\r\n  , WHITESPACE = 9\r\n  , EOF = 10\r\n  , HEX = 11\r\n\r\nvar map = [\r\n    'block-comment'\r\n  , 'line-comment'\r\n  , 'preprocessor'\r\n  , 'operator'\r\n  , 'integer'\r\n  , 'float'\r\n  , 'ident'\r\n  , 'builtin'\r\n  , 'keyword'\r\n  , 'whitespace'\r\n  , 'eof'\r\n  , 'integer'\r\n]\r\n\r\nfunction tokenize(opt) {\r\n  var i = 0\r\n    , total = 0\r\n    , mode = NORMAL\r\n    , c\r\n    , last\r\n    , content = []\r\n    , tokens = []\r\n    , token_idx = 0\r\n    , token_offs = 0\r\n    , line = 1\r\n    , col = 0\r\n    , start = 0\r\n    , isnum = false\r\n    , isoperator = false\r\n    , input = ''\r\n    , len\r\n\r\n  opt = opt || {}\r\n  var allBuiltins = builtins100\r\n  var allLiterals = literals100\r\n  if (opt.version === '300 es') {\r\n    allBuiltins = builtins300es\r\n    allLiterals = literals300es\r\n  }\r\n\r\n  // cache by name\r\n  var builtinsDict = {}, literalsDict = {}\r\n  for (var i = 0; i < allBuiltins.length; i++) {\r\n    builtinsDict[allBuiltins[i]] = true\r\n  }\r\n  for (var i = 0; i < allLiterals.length; i++) {\r\n    literalsDict[allLiterals[i]] = true\r\n  }\r\n\r\n  return function(data) {\r\n    tokens = []\r\n    if (data !== null) return write(data)\r\n    return end()\r\n  }\r\n\r\n  function token(data) {\r\n    if (data.length) {\r\n      tokens.push({\r\n        type: map[mode]\r\n      , data: data\r\n      , position: start\r\n      , line: line\r\n      , column: col\r\n      })\r\n    }\r\n  }\r\n\r\n  function write(chunk) {\r\n    i = 0\r\n\r\n    if (chunk.toString) chunk = chunk.toString()\r\n\r\n    input += chunk.replace(/\\r\\n/g, '\\n')\r\n    len = input.length\r\n\r\n\r\n    var last\r\n\r\n    while(c = input[i], i < len) {\r\n      last = i\r\n\r\n      switch(mode) {\r\n        case BLOCK_COMMENT: i = block_comment(); break\r\n        case LINE_COMMENT: i = line_comment(); break\r\n        case PREPROCESSOR: i = preprocessor(); break\r\n        case OPERATOR: i = operator(); break\r\n        case INTEGER: i = integer(); break\r\n        case HEX: i = hex(); break\r\n        case FLOAT: i = decimal(); break\r\n        case TOKEN: i = readtoken(); break\r\n        case WHITESPACE: i = whitespace(); break\r\n        case NORMAL: i = normal(); break\r\n      }\r\n\r\n      if(last !== i) {\r\n        switch(input[last]) {\r\n          case '\\n': col = 0; ++line; break\r\n          default: ++col; break\r\n        }\r\n      }\r\n    }\r\n\r\n    total += i\r\n    input = input.slice(i)\r\n    return tokens\r\n  }\r\n\r\n  function end(chunk) {\r\n    if(content.length) {\r\n      token(content.join(''))\r\n    }\r\n\r\n    mode = EOF\r\n    token('(eof)')\r\n    return tokens\r\n  }\r\n\r\n  function normal() {\r\n    content = content.length ? [] : content\r\n\r\n    if(last === '/' && c === '*') {\r\n      start = total + i - 1\r\n      mode = BLOCK_COMMENT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(last === '/' && c === '/') {\r\n      start = total + i - 1\r\n      mode = LINE_COMMENT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(c === '#') {\r\n      mode = PREPROCESSOR\r\n      start = total + i\r\n      return i\r\n    }\r\n\r\n    if(/\\s/.test(c)) {\r\n      mode = WHITESPACE\r\n      start = total + i\r\n      return i\r\n    }\r\n\r\n    isnum = /\\d/.test(c)\r\n    isoperator = /[^\\w_]/.test(c)\r\n\r\n    start = total + i\r\n    mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN\r\n    return i\r\n  }\r\n\r\n  function whitespace() {\r\n    if(/[^\\s]/g.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function preprocessor() {\r\n    if((c === '\\r' || c === '\\n') && last !== '\\\\') {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function line_comment() {\r\n    return preprocessor()\r\n  }\r\n\r\n  function block_comment() {\r\n    if(c === '/' && last === '*') {\r\n      content.push(c)\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i + 1\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function operator() {\r\n    if(last === '.' && /\\d/.test(c)) {\r\n      mode = FLOAT\r\n      return i\r\n    }\r\n\r\n    if(last === '/' && c === '*') {\r\n      mode = BLOCK_COMMENT\r\n      return i\r\n    }\r\n\r\n    if(last === '/' && c === '/') {\r\n      mode = LINE_COMMENT\r\n      return i\r\n    }\r\n\r\n    if(c === '.' && content.length) {\r\n      while(determine_operator(content));\r\n\r\n      mode = FLOAT\r\n      return i\r\n    }\r\n\r\n    if(c === ';' || c === ')' || c === '(') {\r\n      if(content.length) while(determine_operator(content));\r\n      token(c)\r\n      mode = NORMAL\r\n      return i + 1\r\n    }\r\n\r\n    var is_composite_operator = content.length === 2 && c !== '='\r\n    if(/[\\w_\\d\\s]/.test(c) || is_composite_operator) {\r\n      while(determine_operator(content));\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function determine_operator(buf) {\r\n    var j = 0\r\n      , idx\r\n      , res\r\n\r\n    do {\r\n      idx = operators.indexOf(buf.slice(0, buf.length + j).join(''))\r\n      res = operators[idx]\r\n\r\n      if(idx === -1) {\r\n        if(j-- + buf.length > 0) continue\r\n        res = buf.slice(0, 1).join('')\r\n      }\r\n\r\n      token(res)\r\n\r\n      start += res.length\r\n      content = content.slice(res.length)\r\n      return content.length\r\n    } while(1)\r\n  }\r\n\r\n  function hex() {\r\n    if(/[^a-fA-F0-9]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function integer() {\r\n    if(c === '.') {\r\n      content.push(c)\r\n      mode = FLOAT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[eE]/.test(c)) {\r\n      content.push(c)\r\n      mode = FLOAT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(c === 'x' && content.length === 1 && content[0] === '0') {\r\n      mode = HEX\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[^\\d]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function decimal() {\r\n    if(c === 'f') {\r\n      content.push(c)\r\n      last = c\r\n      i += 1\r\n    }\r\n\r\n    if(/[eE]/.test(c)) {\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if ((c === '-' || c === '+') && /[eE]/.test(last)) {\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[^\\d]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function readtoken() {\r\n    if(/[^\\d\\w_]/.test(c)) {\r\n      var contentstr = content.join('')\r\n      if(literalsDict[contentstr]) {\r\n        mode = KEYWORD\r\n      } else if(builtinsDict[contentstr]) {\r\n        mode = BUILTIN\r\n      } else {\r\n        mode = IDENT\r\n      }\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n}\r\n","var tokenize = require('./index')\r\n\r\nmodule.exports = tokenizeString\r\n\r\nfunction tokenizeString(str, opt) {\r\n  var generator = tokenize(opt)\r\n  var tokens = []\r\n\r\n  tokens = tokens.concat(generator(str))\r\n  tokens = tokens.concat(generator(null))\r\n\r\n  return tokens\r\n}\r\n","module.exports = getTokenDepth\n\nfunction getTokenDepth(tokens) {\n  var loop  = false\n  var depth = 0\n\n  for (var i = 0; i < tokens.length; i++) {\n    loop = loop || (tokens[i].type === 'keyword' && (\n      tokens[i].data === 'for'\n    ))\n\n    switch (tokens[i].data) {\n      case '(': tokens[i].depth = loop ? depth++ : depth; break\n      case '{': tokens[i].depth = loop ? depth : depth++; loop = false; break\n      case '}': tokens[i].depth = --depth; break\n      default:  tokens[i].depth = depth\n    }\n  }\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    var index = i + 1\n    if (token.type !== 'ident' && token.type !== 'keyword') continue\n    skipArrayArguments()\n    if (tokens[index].type !== 'ident') continue\n    skipArrayArguments()\n    index++\n    if (tokens[index].data !== '(') continue\n\n    while (tokens[index] && tokens[index].data !== ';' && tokens[index].data !== '{') {\n      tokens[index++].depth++\n    }\n    if (tokens[index] && tokens[index].data === '{') tokens[index].depth++\n  }\n\n  return tokens\n\n  function skipArrayArguments() {\n    while (tokens[index] && (\n      tokens[index].type === 'whitespace' ||\n      tokens[index].data === '[' ||\n      tokens[index].data === ']' ||\n      tokens[index].data === 'integer'\n    )) index++\n  }\n}\n","module.exports = tokenScope\n\nfunction tokenScope(tokens) {\n  var stack  = [0]\n  var inc    = stack[0]\n  var ldepth = 0\n\n  if (!tokens || !tokens.length) return tokens\n  if (!('depth' in tokens[0])) {\n    throw new Error('glsl-token-scope: No scope depth defined on tokens! Use glsl-token-depth on these tokens first')\n  }\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    var depth = token.depth\n\n    if (depth > ldepth) {\n      stack.push(++inc)\n    } else\n    if (depth < ldepth) {\n      stack.splice(-1, 1)\n    }\n\n    token.scope = stack[stack.length - 1]\n    token.stack = stack.slice()\n    ldepth = token.depth\n  }\n\n  return tokens\n}\n","module.exports = properties\n\nfunction properties(tokens) {\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    token.property = false\n\n    if (token.type !== 'ident') continue\n\n    var j = i\n    while (tokens[--j] && tokens[j].type === 'whitespace');\n    if (!tokens[j]) continue\n    if (tokens[j].type !== 'operator') continue\n    if (tokens[j].data !== '.') continue\n\n    token.property = true\n  }\n\n  return tokens\n}\n","module.exports = {\n    '<<=': true\n  , '>>=': true\n  , '++': true\n  , '--': true\n  , '+=': true\n  , '-=': true\n  , '*=': true\n  , '/=': true\n  , '%=': true\n  , '&=': true\n  , '^=': true\n  , '|=': true\n  , '=': true\n}\n","module.exports = {\n    'precision': true\n  , 'highp': true\n  , 'mediump': true\n  , 'lowp': true\n  , 'attribute': true\n  , 'const': true\n  , 'uniform': true\n  , 'varying': true\n  , 'break': true\n  , 'continue': true\n  , 'do': true\n  , 'for': true\n  , 'while': true\n  , 'if': true\n  , 'else': true\n  , 'in': true\n  , 'out': true\n  , 'inout': true\n  , 'true': true\n  , 'false': true\n  , 'return': true\n}\n","var assignments = require('./assignments')\nvar ignoredKeywords = require('./ignored')\n\nmodule.exports = assigns\n\n// Here be dragons. Apologies in advance for the hairy code!\nfunction assigns(tokens) {\n  var idx = 0\n\n  // Determine if a value has been assigned, e.g.\n  // x = 1.0;\n  // float x = 1.0;\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    var type  = token.type\n\n    token.assignment = false\n    token.declaration = false\n    if (type !== 'ident' && type !== 'builtin') continue\n    idx = i + 1\n\n    skipWhitespace(+1)\n    if (tokens[idx].type !== 'operator') continue\n    if (!assignments[tokens[idx].data]) continue\n    token.assignment = true\n  }\n\n  // Determine if a value is being defined, e.g.\n  // float x;\n  // float x, y, z;\n  // float x, y = vec3(sin(1.0 + 3.0)), z;\n  // float[3][2] x, y = vec3(sin(1.0 + 3.0)), z;\n  // float[][2] x, y = vec3(sin(1.0 + 3.0)), z;\n  // float x[2], y = vec3(sin(1.0 + 3.0)), z[4];\n  // float x(float y, float z) {};\n  // float x(float y[2], Thing[3] z) {};\n  // Thing x[2], y = Another(sin(1.0 + 3.0)), z[4];\n  for (var i = 0; i < tokens.length; i++) {\n    var datatype = tokens[i]\n    var type     = datatype.type\n    var data     = datatype.data\n\n    datatype.declaration = false\n\n    if (type === 'keyword') {\n      if (ignoredKeywords[data]) continue\n    } else\n    if (type !== 'ident') continue\n\n    idx = i + 1\n\n    skipArrayDimensions()\n    if (tokens[idx].type !== 'ident') continue\n    tokens[idx++].declaration = true\n    skipArrayDimensions()\n\n    // Function arguments/parameters\n    if (tokens[idx].data === '(') {\n      idx++\n\n      skipWhitespace(+1)\n      while (tokens[idx] && tokens[idx].data !== ')') {\n        if (tokens[idx].type !== 'keyword' && tokens[idx].type !== 'ident') break\n        idx++\n        skipWhitespace(+1)\n        if (tokens[idx].type !== 'ident') continue\n        tokens[idx++].declaration = true\n        skipWhitespace(+1)\n        skipArrayDimensions()\n        skipWhitespace(+1)\n        if (tokens[idx].data !== ',') continue\n        idx++\n        skipWhitespace(+1)\n      }\n\n      i = idx\n      continue\n    }\n\n    // Declaration Lists\n    while (tokens[idx] && tokens[idx].data !== ';') {\n      if (tokens[idx].data === ',') {\n        idx++\n        skipWhitespace(+1)\n        if (tokens[idx].declaration = tokens[idx].type === 'ident') idx++\n      } else {\n        skipWhitespace(+1)\n        skipParens()\n        skipWhitespace(+1)\n        idx++\n      }\n    }\n\n    i = idx\n  }\n\n  // Handle struct declarations:\n  // struct declaration {\n  //   float x, y, z;\n  //   Other w;\n  // } declaration;\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    if (token.type !== 'keyword') continue\n    if (token.data !== 'struct') continue\n    idx = i + 1\n    skipWhitespace(+1)\n    if (tokens[idx].type !== 'ident') continue\n\n    idx++\n    skipWhitespace(+1)\n    if (tokens[idx++].data !== '{') continue\n    skipWhitespace(+1)\n\n    while (tokens[idx].type === 'ident' || tokens[idx].type === 'keyword') {\n      do {\n        idx++\n        skipWhitespace(+1)\n        tokens[idx].structMember = true\n        tokens[idx].declaration = false\n        idx++\n        skipArrayDimensions()\n      } while (tokens[idx].data === ',')\n\n      if (tokens[idx].data === ';') idx++\n      skipWhitespace()\n    }\n\n    idx++\n    skipWhitespace(+1)\n    if (tokens[idx].type !== 'ident') continue\n    tokens[idx].declaration = true\n    skipWhitespace(+1)\n\n    while (tokens[++idx].data === ',') {\n      skipWhitespace(+1)\n      idx++\n      skipWhitespace(+1)\n      if (tokens[idx].type === 'ident') tokens[idx].declaration = true\n      skipWhitespace(+1)\n    }\n  }\n\n  return tokens\n\n  function skipWhitespace(n) {\n    while (tokens[idx] && tokens[idx].type === 'whitespace') idx++\n  }\n\n  function skipArrayDimensions() {\n    while (tokens[idx] && (\n         tokens[idx].type === 'integer'\n      || tokens[idx].data === '['\n      || tokens[idx].data === ']'\n      || tokens[idx].type === 'whitespace'\n    )) idx++\n  }\n\n  function skipParens() {\n    if (!tokens[idx]) return\n    if (tokens[idx].data !== '(') return\n    var depth = 0\n    var a = idx\n    do {\n      if (tokens[idx].data === ';') break\n      if (tokens[idx].data === '(') depth++\n      if (tokens[idx].data === ')') depth--\n    } while(depth && tokens[++idx])\n  }\n}\n","module.exports = glslTokenDescope\n\nfunction glslTokenDescope(tokens, rename) {\n  require('glsl-token-depth')(tokens)\n  require('glsl-token-scope')(tokens)\n  require('glsl-token-properties')(tokens)\n  require('glsl-token-assignments')(tokens)\n\n  var scope   = getScope(tokens)\n  var renamer = rename || defaultRenamer()\n  var map     = {}\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    var stack = token.stack\n    var name  = token.data\n\n    token.descoped = false\n\n    if (token.type !== 'ident') continue\n    if (token.property) continue\n    if (token.structMember) continue\n\n    var bound = false\n\n    for (var j = stack.length - 1; j >= 0; j--) {\n      var s = scope[stack[j]]\n      if (!s) continue\n      if (!s[name]) continue\n\n      bound = true\n\n      // exit if declaration not in top-level scope\n      if (j) break\n\n      token.descoped = token.data\n      token.data = map[name] = map[name] || renamer(name, token) || token.data\n    }\n\n    // Handle unbound variables, i.e. ones not defined anywhere\n    // in the shader source but still used.\n    if (!bound) {\n      token.descoped = token.data\n      token.data = map[name] = map[name] || renamer(name, token) || token.data\n    }\n  }\n\n  return tokens\n}\n\nfunction defaultRenamer() {\n  var k = 0\n\n  return function rename(name) {\n    return name + '_' + (k++).toString(36)\n  }\n}\n\nfunction getScope(tokens) {\n  var scope = {}\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    if (token.declaration) {\n      scope[token.scope] = scope[token.scope] || {}\n      scope[token.scope][token.data] = token\n    }\n  }\n\n  return scope\n}\n","module.exports = toString\n\nfunction toString(tokens) {\n  var output = []\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].type === 'eof') continue\n    output.push(tokens[i].data)\n  }\n\n  return output.join('')\n}\n","module.exports = functions\n\nfunction functions (tokens) {\n  var returnType = null\n  var defnName = null\n  var braceDepth = 0\n  var braceStart = 0\n  var defnStart = 0\n  var argFinish = 0\n  var argStart = 0\n  var output = []\n  var i, j, token\n\n  // The following loop detects functions with bodies of any type,\n  // including structs. e.g.\n  // void main() {...}\n  // vec4 fn(vec3 a) {...}\n  // Ray3 fn(vec3 ro, vec3 rd) {...}\n  for (i = 0, j; i < tokens.length; i++) {\n    token = tokens[i]\n    if (token.data === '{') {\n      // If already in a function, keep track of opening braces\n      if (braceDepth && braceDepth++) continue\n\n      // Stepping backwards from the closing brace, find the end\n      // of the arguments list. There should only be whitespace on\n      // the way there.\n      j = findPrevious(i, findOp(')'), findOp())\n      if (j < 0) continue\n      argFinish = j\n\n      // Step backwards to find the beginning of the arguments list. If there's\n      // a nested paranthesis in there, then it's definitely not a function.\n      j = findPrevious(j, findOp('('), findOp(')'))\n      if (j < 0) continue\n      argStart = j\n\n      // Continue stepping backwards past any whitespace to find the\n      // function name. If the token isn't an identifier then it's not a\n      // function so we bail\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n      if (tokens[j].type !== 'ident') continue\n      defnName = tokens[j].data\n\n      // The next non-whitespace token should be the return type of\n      // the function\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n\n      braceDepth = 1\n      braceStart = i\n      returnType = tokens[j].data\n      defnStart = j\n\n      // There are cases when a function definition includes a\n      // precision qualifier, e.g. highp float random();\n      // So we backtrack one extra step to check if that's the\n      // case, and handle it :)\n      var k = findPrevious(j, findGlyph)\n      switch (tokens[k] && tokens[k].data) {\n        case 'lowp':\n        case 'highp':\n        case 'mediump':\n          defnStart = k\n      }\n    } else\n    if (braceDepth && token.data === '}') {\n      if (--braceDepth) continue\n\n      output.push({\n        name: defnName,\n        type: returnType,\n        body: [braceStart + 1, i],\n        args: [argStart, argFinish + 1],\n        outer: [defnStart, i + 1]\n      })\n    }\n  }\n\n  // This loop is for handling the edge case of functions defined\n  // without a body. Generally, this body is defined later in the file.\n  // void main();\n  // vec2 doModel(vec3 p);\n  // Note the replacement of curly braces with a semicolon.\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i]\n    if (token.data === ';') {\n      // Like before, we start from a semicolon and find the\n      // bounds of the argument list to find the function name\n      j = findPrevious(i, findOp(')'), findOp())\n      if (j < 0) continue\n      argFinish = j\n      j = findPrevious(j, findOp('('), findOp(')'))\n      if (j < 0) continue\n      argStart = j\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n      if (tokens[j].type !== 'ident') continue\n      defnName = tokens[j].data\n\n      // Try and find an ident or builtin character, which should be\n      // our return type. If so, it'll be the very first preceding glyph.\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n      if (tokens[j].type === 'operator') continue\n      if (tokens[j].data === 'return') continue\n      returnType = tokens[j].data\n\n      output.push({\n        name: defnName,\n        type: returnType,\n        body: false,\n        args: [argStart, argFinish + 1],\n        outer: [j, i + 1]\n      })\n    }\n  }\n\n  return output.sort(function (a, b) {\n    return a.outer[0] - b.outer[0]\n  })\n\n  function findPrevious (start, match, bail) {\n    for (var i = start - 1; i >= 0; i--) {\n      if (match(tokens[i])) return i\n      if (bail && bail(tokens[i])) return -1\n    }\n\n    return -1\n  }\n}\n\nfunction findOp (data) {\n  return function (token) {\n    return token.type === 'operator' && (!data || token.data === data)\n  }\n}\n\nfunction findGlyph (token) {\n  return token.type !== 'whitespace'\n}\n","import { Material } from 'three';\n\nvar keywords = {\n  positon: 'csm_Position',\n  emissive: 'csm_Emissive',\n  normal: 'csm_Normal',\n  pointSize: 'csm_PointSize',\n  diffuseColor: 'csm_DiffuseColor',\n  fragColor: 'csm_FragColor'\n};\n\nconst VERT = {\n  [`${keywords.normal}`]: {\n    '#include <defaultnormal_vertex>': `\n    vec3 transformedNormal = ${keywords.normal};\n    #ifdef USE_INSTANCING\n    \t// this is in lieu of a per-instance normal-matrix\n    \t// shear transforms in the instance matrix are not supported\n    \tmat3 m = mat3( instanceMatrix );\n    \ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n    \ttransformedNormal = m * transformedNormal;\n    #endif\n    transformedNormal = normalMatrix * transformedNormal;\n    #ifdef FLIP_SIDED\n    \ttransformedNormal = - transformedNormal;\n    #endif\n    #ifdef USE_TANGENT\n    \tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n    \t#ifdef FLIP_SIDED\n    \t\ttransformedTangent = - transformedTangent;\n    \t#endif\n    #endif\n    `\n  },\n  [`${keywords.positon}`]: {\n    '#include <project_vertex>': `\n    transformed = ${keywords.positon};\n    #include <project_vertex>\n  `\n  },\n  [`${keywords.pointSize}`]: {\n    'gl_PointSize = size;': `gl_PointSize = ${keywords.pointSize};`\n  }\n};\nconst FRAG = {\n  [`${keywords.diffuseColor}`]: {\n    '#include <color_fragment>': `\n    #include <color_fragment>\n    diffuseColor = ${keywords.diffuseColor};\n  `\n  },\n  [`${keywords.fragColor}`]: {\n    '#include <output_fragment>': `\n    #include <output_fragment>\n    gl_FragColor  = ${keywords.fragColor};\n  `\n  },\n  [`${keywords.emissive}`]: {\n    'vec3 totalEmissiveRadiance = emissive;': `\n    vec3 totalEmissiveRadiance = ${keywords.emissive};\n    `\n  }\n};\n\nclass CustomShaderMaterial extends Material {\n  constructor(baseMaterial, fragmentShader, vertexShader, uniforms, opts) {\n    // @ts-ignore\n    const base = new baseMaterial(opts);\n    super();\n    this.base = base;\n    this.uniforms = uniforms || {};\n\n    for (const key in this.base) {\n      // @ts-ignore\n      if (this[key] === undefined) this[key] = 0; // @ts-ignore\n\n      this[key] = this.base[key];\n    }\n\n    this.update(fragmentShader, vertexShader, uniforms);\n  }\n\n  update(fragmentShader, vertexShader, uniforms) {\n    this.generateMaterial(fragmentShader, vertexShader, uniforms);\n  }\n\n  generateMaterial(fragmentShader, vertexShader, uniforms) {\n    const parsedFragmentShdaer = this.parseShader(fragmentShader);\n    const parsedVertexShdaer = this.parseShader(vertexShader);\n    this.uniforms = uniforms || {};\n\n    this.customProgramCacheKey = () => {\n      return this.uuid;\n    };\n\n    this.onBeforeCompile = shader => {\n      if (parsedFragmentShdaer) {\n        const patchedFragmentShdaer = this.patchShader(parsedFragmentShdaer, shader.fragmentShader, FRAG);\n        shader.fragmentShader = patchedFragmentShdaer;\n      }\n\n      if (parsedVertexShdaer) {\n        const patchedVertexShdaer = this.patchShader(parsedVertexShdaer, shader.vertexShader, VERT);\n        shader.vertexShader = '#define IS_VERTEX;\\n' + patchedVertexShdaer;\n      }\n\n      shader.uniforms = { ...shader.uniforms,\n        ...this.uniforms\n      };\n      this.uniforms = shader.uniforms;\n      this.needsUpdate = true;\n    };\n  }\n\n  patchShader(customShader, shader, patchMap) {\n    let patchedShader = shader;\n    Object.keys(patchMap).forEach(name => {\n      Object.keys(patchMap[name]).forEach(key => {\n        if (customShader.main.includes(name)) {\n          patchedShader = replaceAll(patchedShader, key, patchMap[name][key]);\n        }\n      });\n    });\n    patchedShader = patchedShader.replace('void main() {', `\n          ${customShader.header}\n          void main() {\n            vec3 csm_Position;\n            vec3 csm_Normal;\n            vec3 csm_Emissive;\n\n            #ifdef IS_VERTEX\n              csm_Position = position;\n            #endif\n\n            #ifdef IS_VERTEX\n              csm_Normal = normal;\n            #endif\n            \n            #ifndef IS_VERTEX\n              #ifdef STANDARD\n                csm_Emissive = emissive;\n              #endif\n            #endif\n\n            vec4 csm_DiffuseColor = vec4(1., 0., 0., 1.);\n            vec4 csm_FragColor = vec4(1., 0., 0., 1.);\n            float csm_PointSize = 1.;\n\n            ${customShader.main}\n          `);\n    patchedShader = customShader.defines + patchedShader;\n    return patchedShader;\n  }\n\n  parseShader(shader) {\n    if (!shader) return;\n    const parsedShader = {\n      defines: '',\n      header: '',\n      main: ''\n    };\n    const main = shader.match(/void\\s*main\\s*\\w*\\s*\\([\\w\\s,]*\\)\\s*{([\\w\\W]*?)}/g);\n\n    if (main != null && main.length) {\n      const mainBody = main[0].match(/\\{((.|\\n)*?)\\}/g);\n\n      if (mainBody != null && mainBody.length) {\n        parsedShader.main = mainBody[0];\n      }\n\n      const rest = shader.replace(main[0], '');\n      const defines = rest.match(/#(.*?;)/g) || [];\n      const header = defines.reduce((prev, curr) => prev.replace(curr, ''), rest);\n      parsedShader.header = header;\n      parsedShader.defines = defines.join('\\n');\n    }\n\n    return parsedShader;\n  }\n\n}\n\nconst replaceAll = (str, find, rep) => str.split(find).join(rep);\n\nexport { CustomShaderMaterial as default };\n","import * as THREE from 'three';\nimport { Vector3, Vector2, Vector4, Matrix3, Matrix4, Color as Color$1, Texture as Texture$1, MathUtils } from 'three';\nimport tokenize from 'glsl-tokenizer';\nimport descope from 'glsl-token-descope';\nimport stringify from 'glsl-token-string';\nimport tokenFunctions from 'glsl-token-functions';\nimport CustomShaderMaterial from 'three-custom-shader-material/vanilla';\n\nfunction getUniform(value) {\n  if (typeof value === 'string') {\n    return new Color$1(value);\n  }\n\n  return value;\n}\nfunction getSpecialParameters(label) {\n  switch (label) {\n    case 'alpha':\n      return {\n        min: 0,\n        max: 1\n      };\n\n    case 'scale':\n      return {\n        min: 0\n      };\n\n    case 'map':\n      return {\n        image: undefined\n      };\n\n    default:\n      return {};\n  }\n}\nfunction isSerializableType(prop) {\n  return prop instanceof Vector3 || prop instanceof Vector2 || prop instanceof Vector4 || prop instanceof Matrix3 || prop instanceof Matrix4;\n}\nfunction serializeProp(prop) {\n  if (isSerializableType(prop)) {\n    return prop.toArray();\n  } else if (prop instanceof Color$1) {\n    return '#' + prop.clone().convertLinearToSRGB().getHexString();\n  } else if (prop instanceof Texture$1) {\n    return prop.image.src;\n  }\n\n  return prop;\n}\n\nconst BlendModes = {\n  normal: 'normal',\n  add: 'add',\n  subtract: 'subtract',\n  multiply: 'multiply',\n  lighten: 'lighten',\n  darken: 'darken',\n  divide: 'divide',\n  overlay: 'overlay',\n  screen: 'screen',\n  softlight: 'softlight',\n  negation: 'negation',\n  reflect: 'reflect'\n};\nconst NoiseTypes = {\n  perlin: 'perlin',\n  simplex: 'simplex',\n  cell: 'cell',\n  curl: 'curl',\n  white: 'white'\n};\nconst MappingTypes = {\n  local: 'local',\n  world: 'world',\n  uv: 'uv'\n};\nconst ShadingTypes = {\n  phong: THREE.MeshPhongMaterial,\n  physical: THREE.MeshPhysicalMaterial,\n  toon: THREE.MeshToonMaterial,\n  basic: THREE.MeshBasicMaterial,\n  lambert: THREE.MeshLambertMaterial,\n  standard: THREE.MeshStandardMaterial\n};\n\nclass Abstract {\n  constructor(c, props, onParse) {\n    this.uuid = MathUtils.generateUUID().replace(/-/g, '_');\n    this.name = 'LayerMaterial';\n    this.mode = 'normal';\n    this.visible = true;\n    const defaults = Object.getOwnPropertyNames(c).filter(e => e.startsWith('u_'));\n    const uniforms = defaults.reduce((a, v) => {\n      var _Object$getOwnPropert;\n\n      let value = (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(c, v)) == null ? void 0 : _Object$getOwnPropert.value;\n      if (isSerializableType(value) || value instanceof Color$1) value = value.clone();\n      return { ...a,\n        [v.slice(1)]: value\n      };\n    }, {});\n\n    for (const key in uniforms) {\n      const propName = key.split('_')[1];\n      if ((props == null ? void 0 : props[propName]) !== undefined) uniforms[key] = props[propName];\n    }\n\n    if (props) {\n      Object.keys(props).map(key => {\n        if (props[key] !== undefined) {\n          // @ts-ignore\n          this[key] = props[key];\n        }\n      });\n    }\n\n    this.uniforms = {};\n    this.schema = [];\n    const properties = {};\n    Object.keys(uniforms).map(key => {\n      const propName = key.split('_')[1];\n      this.uniforms[`u_${this.uuid}_${propName}`] = {\n        value: getUniform(uniforms[key])\n      };\n      this.schema.push({\n        value: uniforms[key],\n        label: propName\n      });\n      properties[propName] = {\n        set: v => {\n          this.uniforms[`u_${this.uuid}_${propName}`].value = getUniform(v);\n        },\n        get: () => {\n          return this.uniforms[`u_${this.uuid}_${propName}`].value;\n        }\n      };\n    });\n    if (props != null && props.name) this.name = props.name;\n    if (props != null && props.mode) this.mode = props.mode;\n    if (props != null && props.visible) this.visible = props.visible;\n    Object.defineProperties(this, properties);\n    this.vertexShader = '';\n    this.fragmentShader = '';\n    this.vertexVariables = '';\n    this.fragmentVariables = '';\n    this.onParse = onParse;\n    this.buildShaders(c); // Remove Name field from Debugger until a way to\n    // rename Leva folders is found\n    // this.schema.push({\n    //   value: this.name,\n    //   label: 'name',\n    // })\n\n    this.schema.push({\n      value: this.mode,\n      label: 'mode',\n      options: Object.values(BlendModes)\n    });\n    this.schema.push({\n      value: this.visible,\n      label: 'visible'\n    });\n  }\n\n  buildShaders(constructor) {\n    var _this$onParse;\n\n    const shaders = Object.getOwnPropertyNames(constructor).filter(e => e === 'fragmentShader' || e === 'vertexShader').reduce((a, v) => {\n      var _Object$getOwnPropert2;\n\n      return { ...a,\n        [v]: (_Object$getOwnPropert2 = Object.getOwnPropertyDescriptor(constructor, v)) == null ? void 0 : _Object$getOwnPropert2.value\n      };\n    }, {});\n    const tokens = {\n      vert: tokenize(shaders.vertexShader || ''),\n      frag: tokenize(shaders.fragmentShader || '')\n    };\n    const descoped = {\n      vert: descope(tokens.vert, this.renameTokens.bind(this)),\n      frag: descope(tokens.frag, this.renameTokens.bind(this))\n    };\n    const funcs = {\n      vert: tokenFunctions(descoped.vert),\n      frag: tokenFunctions(descoped.frag)\n    };\n    const mainIndex = {\n      vert: funcs.vert.map(e => {\n        return e.name;\n      }).indexOf('main'),\n      frag: funcs.frag.map(e => {\n        return e.name;\n      }).indexOf('main')\n    };\n    const variables = {\n      vert: mainIndex.vert >= 0 ? stringify(descoped.vert.slice(0, funcs.vert[mainIndex.vert].outer[0])) : '',\n      frag: mainIndex.frag >= 0 ? stringify(descoped.frag.slice(0, funcs.frag[mainIndex.frag].outer[0])) : ''\n    };\n    const funcBodies = {\n      vert: mainIndex.vert >= 0 ? this.getShaderFromIndex(descoped.vert, funcs.vert[mainIndex.vert].body) : '',\n      frag: mainIndex.frag >= 0 ? this.getShaderFromIndex(descoped.frag, funcs.frag[mainIndex.frag].body) : ''\n    };\n    this.vertexShader = this.processFinal(funcBodies.vert, true);\n    this.fragmentShader = this.processFinal(funcBodies.frag);\n    this.vertexVariables = variables.vert;\n    this.fragmentVariables = variables.frag;\n    (_this$onParse = this.onParse) == null ? void 0 : _this$onParse.call(this, this);\n    this.schema = this.schema.filter((value, index) => {\n      const _value = value.label;\n      return index === this.schema.findIndex(obj => {\n        return obj.label === _value;\n      });\n    });\n  }\n\n  renameTokens(name) {\n    if (name.startsWith('u_')) {\n      const slice = name.slice(2);\n      return `u_${this.uuid}_${slice}`;\n    } else if (name.startsWith('v_')) {\n      const slice = name.slice(2);\n      return `v_${this.uuid}_${slice}`;\n    } else if (name.startsWith('f_')) {\n      const slice = name.slice(2);\n      return `f_${this.uuid}_${slice}`;\n    } else {\n      return name;\n    }\n  }\n\n  processFinal(shader, isVertex) {\n    const s = shader.replace(/\\sf_/gm, ` f_${this.uuid}_`).replace(/\\(f_/gm, `(f_${this.uuid}_`);\n    const returnValue = s.match(/^.*return.*$/gm);\n    let sReplaced = s.replace(/^.*return.*$/gm, '');\n\n    if (returnValue != null && returnValue[0]) {\n      const returnVariable = returnValue[0].replace('return', '').trim().replace(';', '');\n      const blendMode = this.getBlendMode(returnVariable, 'lamina_finalColor');\n      sReplaced += isVertex ? `lamina_finalPosition = ${returnVariable};` : `lamina_finalColor = ${blendMode};`;\n    }\n\n    return sReplaced;\n  }\n\n  getShaderFromIndex(tokens, index) {\n    return stringify(tokens.slice(index[0], index[1]));\n  }\n\n  getBlendMode(b, a) {\n    switch (this.mode) {\n      default:\n      case 'normal':\n        return `lamina_blend_alpha(${a}, ${b}, ${b}.a)`;\n\n      case 'add':\n        return `lamina_blend_add(${a}, ${b}, ${b}.a)`;\n\n      case 'subtract':\n        return `lamina_blend_subtract(${a}, ${b}, ${b}.a)`;\n\n      case 'multiply':\n        return `lamina_blend_multiply(${a}, ${b}, ${b}.a)`;\n\n      case 'lighten':\n        return `lamina_blend_lighten(${a}, ${b}, ${b}.a)`;\n\n      case 'darken':\n        return `lamina_blend_darken(${a}, ${b}, ${b}.a)`;\n\n      case 'divide':\n        return `lamina_blend_divide(${a}, ${b}, ${b}.a)`;\n\n      case 'overlay':\n        return `lamina_blend_overlay(${a}, ${b}, ${b}.a)`;\n\n      case 'screen':\n        return `lamina_blend_screen(${a}, ${b}, ${b}.a)`;\n\n      case 'softlight':\n        return `lamina_blend_softlight(${a}, ${b}, ${b}.a)`;\n\n      case 'reflect':\n        return `lamina_blend_reflect(${a}, ${b}, ${b}.a)`;\n\n      case 'negation':\n        return `lamina_blend_negation(${a}, ${b}, ${b}.a)`;\n    }\n  }\n\n  getSchema() {\n    const latestSchema = this.schema.map(({\n      label,\n      options,\n      ...rest\n    }) => {\n      return {\n        label,\n        options,\n        ...getSpecialParameters(label),\n        ...rest,\n        // @ts-ignore\n        value: serializeProp(this[label])\n      };\n    });\n    return latestSchema;\n  }\n\n  serialize() {\n    const name = this.constructor.name.split('$')[0];\n    let nonUniformPropKeys = Object.keys(this);\n    nonUniformPropKeys = nonUniformPropKeys.filter(e => !['uuid', 'uniforms', 'schema', 'fragmentShader', 'vertexShader', 'fragmentVariables', 'vertexVariables', 'attribs', 'events', '__r3f', 'onParse'].includes(e));\n    const nonUniformProps = {};\n    nonUniformPropKeys.forEach(k => {\n      // @ts-ignore\n      nonUniformProps[k] = this[k];\n    });\n    const props = {};\n\n    for (const key in this.uniforms) {\n      const name = key.replace(`u_${this.uuid}_`, '');\n      props[name] = serializeProp(this.uniforms[key].value);\n    }\n\n    return {\n      constructor: name,\n      properties: { ...props,\n        ...nonUniformProps\n      }\n    };\n  }\n\n}\n\nclass Depth extends Abstract {\n  constructor(props) {\n    super(Depth, {\n      name: 'Depth',\n      ...props\n    }, self => {\n      self.schema.push({\n        value: self.mapping,\n        label: 'mapping',\n        options: ['vector', 'world', 'camera']\n      });\n      const mapping = Depth.getMapping(self.uuid, self.mapping);\n      self.fragmentShader = self.fragmentShader.replace('lamina_mapping_template', mapping);\n    });\n    this.mapping = 'vector';\n  }\n\n  static getMapping(uuid, type) {\n    switch (type) {\n      default:\n      case 'vector':\n        return `length(v_${uuid}_worldPosition - u_${uuid}_origin)`;\n\n      case 'world':\n        return `length(v_${uuid}_position - vec3(0.))`;\n\n      case 'camera':\n        return `length(v_${uuid}_worldPosition - cameraPosition)`;\n    }\n  }\n\n}\nDepth.u_near = 2;\nDepth.u_far = 10;\nDepth.u_origin = new Vector3(0, 0, 0);\nDepth.u_colorA = 'white';\nDepth.u_colorB = 'black';\nDepth.u_alpha = 1;\nDepth.vertexShader = `\n  varying vec3 v_worldPosition;\n  varying vec3 v_position;\n\n  void main() {\n    v_worldPosition = (vec4(position, 1.0) * modelMatrix).xyz;\n    v_position = position;\n  }\n  `;\nDepth.fragmentShader = `   \n    uniform float u_alpha;\n    uniform float u_near;\n    uniform float u_far;\n    uniform float u_isVector;\n    uniform vec3 u_origin;\n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n\n    varying vec3 v_worldPosition;\n    varying vec3 v_position;\n\n    void main() {\n      float f_dist = lamina_mapping_template;\n      float f_depth = (f_dist - u_near) / (u_far - u_near);\n\t\t\tvec3 f_depthColor =  mix(u_colorB, u_colorA, 1.0 - clamp(f_depth, 0., 1.));\n  \n  \n      return vec4(f_depthColor, u_alpha);\n    }\n  `;\n\nclass Color extends Abstract {\n  constructor(props) {\n    super(Color, {\n      name: 'Color',\n      ...props\n    });\n  }\n\n}\nColor.u_color = 'red';\nColor.u_alpha = 1;\nColor.fragmentShader = `   \n    uniform vec3 u_color;\n    uniform float u_alpha;\n\n    void main() {\n      return vec4(u_color, u_alpha);\n    }\n  `;\n\nclass Noise extends Abstract {\n  constructor(props) {\n    super(Noise, {\n      name: 'noise',\n      ...props\n    }, self => {\n      self.schema.push({\n        value: self.type,\n        label: 'type',\n        options: Object.values(NoiseTypes)\n      });\n      self.schema.push({\n        value: self.mapping,\n        label: 'mapping',\n        options: Object.values(MappingTypes)\n      });\n      const noiseFunc = Noise.getNoiseFunction(self.type);\n      const mapping = Noise.getMapping(self.mapping);\n      self.vertexShader = self.vertexShader.replace('lamina_mapping_template', mapping);\n      self.fragmentShader = self.fragmentShader.replace('lamina_noise_template', noiseFunc);\n    });\n    this.type = 'perlin';\n    this.mapping = 'local';\n  }\n\n  static getNoiseFunction(type) {\n    switch (type) {\n      default:\n      case 'perlin':\n        return `lamina_noise_perlin`;\n\n      case 'simplex':\n        return `lamina_noise_simplex`;\n\n      case 'cell':\n        return `lamina_noise_worley`;\n\n      case 'white':\n        return `lamina_noise_white`;\n\n      case 'curl':\n        return `lamina_noise_swirl`;\n    }\n  }\n\n  static getMapping(type) {\n    switch (type) {\n      default:\n      case 'local':\n        return `position`;\n\n      case 'world':\n        return `(modelMatrix * vec4(position,1.0)).xyz`;\n\n      case 'uv':\n        return `vec3(uv, 0.)`;\n    }\n  }\n\n}\nNoise.u_colorA = '#666666';\nNoise.u_colorB = '#666666';\nNoise.u_colorC = '#FFFFFF';\nNoise.u_colorD = '#FFFFFF';\nNoise.u_alpha = 1;\nNoise.u_scale = 1;\nNoise.u_offset = new Vector3(0, 0, 0);\nNoise.vertexShader = `\n    varying vec3 v_position;\n\n    void main() {\n        v_position = lamina_mapping_template;\n    }\n  `;\nNoise.fragmentShader = `   \n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n    uniform vec3 u_colorC;\n    uniform vec3 u_colorD;\n    uniform vec3 u_offset;\n\n    uniform float u_alpha;\n    uniform float u_scale;\n\n    varying vec3 v_position;\n\n\n    void main() {\n        float f_n = lamina_noise_template((v_position + u_offset) * u_scale);\n\n        float f_step1 = 0.;\n        float f_step2 = 0.2;\n        float f_step3 = 0.6;\n        float f_step4 = 1.;\n\n        vec3 f_color = mix(u_colorA, u_colorB, smoothstep(f_step1, f_step2, f_n));\n        f_color = mix(f_color, u_colorC, smoothstep(f_step2, f_step3, f_n));\n        f_color = mix(f_color, u_colorD, smoothstep(f_step3, f_step4, f_n));\n\n        return vec4(f_color, u_alpha);\n    }\n  `;\n\nclass Fresnel extends Abstract {\n  constructor(props) {\n    super(Fresnel, {\n      name: 'Fresnel',\n      ...props\n    });\n  }\n\n}\nFresnel.u_color = 'white';\nFresnel.u_alpha = 1;\nFresnel.u_bias = 0;\nFresnel.u_intensity = 1;\nFresnel.u_power = 2;\nFresnel.u_factor = 1;\nFresnel.vertexShader = `\n    varying vec3 v_worldPosition;\n    varying vec3 v_worldNormal;\n\n    void main() {\n        v_worldPosition = vec3(-viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2]);\n        v_worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n        \n    }\n  `;\nFresnel.fragmentShader = `   \n    uniform vec3 u_color;\n    uniform float u_alpha;\n    uniform float u_bias;\n    uniform float u_intensity;\n    uniform float u_power;\n    uniform float u_factor;\n\n    varying vec3 v_worldPosition;\n    varying vec3 v_worldNormal;\n\n    void main() {\n        float f_a = (u_factor  + dot(v_worldPosition, v_worldNormal));\n        float f_fresnel = u_bias + u_intensity * pow(abs(f_a), u_power);\n\n        f_fresnel = clamp(f_fresnel, 0.0, 1.0);\n        return vec4(f_fresnel * u_color, u_alpha);\n    }\n  `;\n\nclass Gradient extends Abstract {\n  constructor(props) {\n    super(Gradient, {\n      name: 'Gradient',\n      ...props\n    }, self => {\n      self.schema.push({\n        value: self.axes,\n        label: 'axes',\n        options: ['x', 'y', 'z']\n      });\n      self.schema.push({\n        value: self.mapping,\n        label: 'mapping',\n        options: Object.values(MappingTypes)\n      });\n      const mapping = Gradient.getMapping(self.mapping);\n      self.vertexShader = self.vertexShader.replace('lamina_mapping_template', mapping || 'local');\n      self.fragmentShader = self.fragmentShader.replace('axes_template', self.axes || 'x');\n    });\n    this.axes = 'x';\n    this.mapping = 'local';\n  }\n\n  static getMapping(type) {\n    switch (type) {\n      default:\n      case 'local':\n        return `position`;\n\n      case 'world':\n        return `(modelMatrix * vec4(position,1.0)).xyz`;\n\n      case 'uv':\n        return `vec3(uv, 0.)`;\n    }\n  }\n\n}\nGradient.u_colorA = 'white';\nGradient.u_colorB = 'black';\nGradient.u_alpha = 1;\nGradient.u_start = 1;\nGradient.u_end = -1;\nGradient.u_contrast = 1;\nGradient.vertexShader = `\n\t\tvarying vec3 v_position;\n\n\t\tvod main() {\n      v_position = lamina_mapping_template;\n\t\t}\n  `;\nGradient.fragmentShader = `   \n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n    uniform vec3 u_axis;\n    uniform float u_alpha;\n    uniform float u_start;\n    uniform float u_end;\n    uniform float u_contrast;\n\n\t\tvarying vec3 v_position;\n\n    void main() {\n\n      float f_step = smoothstep(u_start, u_end, v_position.axes_template * u_contrast);\n      vec3 f_color = mix(u_colorA, u_colorB, f_step);\n\n      return vec4(f_color, u_alpha);\n    }\n  `;\n\nclass Matcap extends Abstract {\n  constructor(props) {\n    super(Matcap, {\n      name: \"Matcap\",\n      ...props\n    });\n  }\n\n}\nMatcap.u_alpha = 1;\nMatcap.u_map = undefined;\nMatcap.vertexShader = `\n    varying vec3 v_position;\n    varying vec3 v_normal;\n    \n    void main() {\n      v_position = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );\n      v_normal = normalize( normalMatrix * normal );\n    }\n    `;\nMatcap.fragmentShader = ` \n\t\tuniform sampler2D u_map;  \n\t\tuniform float u_alpha;  \n\t\tvarying vec3 v_position;\n\t\tvarying vec3 v_normal;\n\n\t\t\n    void main() {\n\t\t\tvec3 f_r = reflect( v_position, v_normal );\n\t\t\tfloat f_m = 2. * sqrt( pow( f_r.x, 2. ) + pow( f_r.y, 2. ) + pow( f_r.z + 1., 2. ) );\n\t\t\tvec2 f_vN = f_r.xy / f_m + .5;\n\n\t\t\tvec3 f_base = texture2D(u_map, f_vN).rgb;\n\n      return vec4(f_base, u_alpha);\n    }\n  `;\n\nclass Texture extends Abstract {\n  constructor(props) {\n    super(Texture, {\n      name: 'Texture',\n      ...props\n    });\n  }\n\n}\nTexture.u_alpha = 1;\nTexture.u_map = undefined;\nTexture.vertexShader = `\n    varying vec2 v_uv;\n    \n    void main() {\n        v_uv = uv;\n    }\n    `;\nTexture.fragmentShader = ` \n\t\tuniform sampler2D u_map;  \n\t\tuniform float u_alpha;  \n\t\tvarying vec2 v_uv;\n\n    void main() {\n\t\t\tvec3 f_color = texture2D(u_map, v_uv).rgb;\n      return vec4(f_color, u_alpha);\n    }\n  `;\n\nclass Displace extends Abstract {\n  constructor(props) {\n    super(Displace, {\n      name: 'Displace',\n      ...props\n    }, self => {\n      self.schema.push({\n        value: self.type,\n        label: 'type',\n        options: Object.values(NoiseTypes)\n      });\n      self.schema.push({\n        value: self.mapping,\n        label: 'mapping',\n        options: Object.values(MappingTypes)\n      });\n      const noiseFunc = Displace.getNoiseFunction(self.type);\n      const mapping = Displace.getMapping(self.mapping);\n      self.vertexVariables = self.vertexVariables.replace('lamina_mapping_template', mapping);\n      self.vertexVariables = self.vertexVariables.replace('lamina_noise_template', noiseFunc);\n    });\n    this.type = 'perlin';\n    this.mapping = 'local';\n  }\n\n  static getNoiseFunction(type) {\n    switch (type) {\n      default:\n      case 'perlin':\n        return `lamina_noise_perlin`;\n\n      case 'simplex':\n        return `lamina_noise_simplex`;\n\n      case 'cell':\n        return `lamina_noise_worley`;\n\n      case 'white':\n        return `lamina_noise_white`;\n\n      case 'curl':\n        return `lamina_noise_swirl`;\n    }\n  }\n\n  static getMapping(type) {\n    switch (type) {\n      default:\n      case 'local':\n        return `p`;\n\n      case 'world':\n        return `(modelMatrix * vec4(p,1.0)).xyz`;\n\n      case 'uv':\n        return `vec3(uv, 0.)`;\n    }\n  }\n\n}\nDisplace.u_strength = 1;\nDisplace.u_scale = 1;\nDisplace.u_offset = new Vector3(0, 0, 0);\nDisplace.vertexShader = `\n       \n      uniform float u_strength;\n      uniform float u_scale;\n      uniform vec3 u_offset;\n\n      vec3 displace(vec3 p) {\n\t\t\t\tvec3 f_position = lamina_mapping_template;\n        float f_n = lamina_noise_template((f_position + u_offset) * u_scale) * u_strength;\n        vec3 f_newPosition = p + (f_n * normal);\n\n\t\t\t\treturn f_newPosition;\n      }\n\n      \n\t\t\tvec3 orthogonal(vec3 v) {\n  \t\t  return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n  \t\t  : vec3(0.0, -v.z, v.y));\n  \t\t}\n  \t\tvec3 recalcNormals(vec3 newPos) {\n  \t\t  float offset = 0.001;\n  \t\t  vec3 tangent = orthogonal(normal);\n  \t\t  vec3 bitangent = normalize(cross(normal, tangent));\n  \t\t  vec3 neighbour1 = position + tangent * offset;\n  \t\t  vec3 neighbour2 = position + bitangent * offset;\n  \t\t  vec3 displacedNeighbour1 = displace(neighbour1);\n  \t\t  vec3 displacedNeighbour2 = displace(neighbour2);\n  \t\t  vec3 displacedTangent = displacedNeighbour1 - newPos;\n  \t\t  vec3 displacedBitangent = displacedNeighbour2 - newPos;\n  \t\t  return normalize(cross(displacedTangent, displacedBitangent));\n  \t\t}\n  \n  \n      void main() {\n       \n\t\t\t\tvec3 f_newPosition = displace(position);\n        lamina_finalNormal = recalcNormals(f_newPosition);\n\n        return f_newPosition;\n      }\n    `;\n\nclass Normal extends Abstract {\n  constructor(props) {\n    super(Normal, {\n      name: 'Normal',\n      ...props\n    });\n  }\n\n}\nNormal.u_alpha = 1;\nNormal.u_direction = new Vector3(1, 1, 1);\nNormal.vertexShader = `   \n  varying vec3 v_normals; \n\n  void main() {\n    v_normals = normal;\n  }\n`;\nNormal.fragmentShader = `   \n  \tuniform float u_alpha;\n  \tuniform vec3 u_color;\n  \tuniform vec3 u_direction;\n\n\t\tvarying vec3 v_normals;\n\n    void main() {\n\t\t\tvec3 f_normalColor = vec3(1.);\n      f_normalColor.x = v_normals.x * u_direction.x;\n      f_normalColor.y = v_normals.y * u_direction.y;\n      f_normalColor.z = v_normals.z * u_direction.z;\n\n      return vec4(f_normalColor, u_alpha);\n    }\n  `;\n\nvar BlendModesChunk = /* glsl */\n`\nvec4 lamina_blend_add(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn min(x + y, 1.0) * opacity + x * (1.0 - opacity);\n\n}\nvec3 lamina_blend_alpha(const in vec3 x, const in vec3 y, const in float opacity) {\n\n\treturn y * opacity + x * (1.0 - opacity);\n\n}\n\nvec4 lamina_blend_alpha(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tfloat a = min(y.a, opacity);\n\n\treturn vec4(lamina_blend_alpha(x.rgb, y.rgb, a), max(x.a, a));\n\n}\nvec4 lamina_blend_average(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn (x + y) * 0.5 * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_color_burn(const in float x, const in float y) {\n\n\treturn (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);\n\n}\n\nvec4 lamina_blend_color_burn(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_color_burn(x.r, y.r),\n\t\tlamina_blend_color_burn(x.g, y.g),\n\t\tlamina_blend_color_burn(x.b, y.b),\n\t\tlamina_blend_color_burn(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_color_dodge(const in float x, const in float y) {\n\n\treturn (y == 1.0) ? y : min(x / (1.0 - y), 1.0);\n\n}\n\nvec4 lamina_blend_color_dodge(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_color_dodge(x.r, y.r),\n\t\tlamina_blend_color_dodge(x.g, y.g),\n\t\tlamina_blend_color_dodge(x.b, y.b),\n\t\tlamina_blend_color_dodge(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_darken(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn min(x, y) * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_difference(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn abs(x - y) * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_divide(const in float x, const in float y) {\n\n\treturn (y > 0.0) ? min(x / y, 1.0) : 1.0;\n\n}\n\nvec4 lamina_blend_divide(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_divide(x.r, y.r),\n\t\tlamina_blend_divide(x.g, y.g),\n\t\tlamina_blend_divide(x.b, y.b),\n\t\tlamina_blend_divide(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_exclusion(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn (x + y - 2.0 * x * y) * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_lighten(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn max(x, y) * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_multiply(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn x * y * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_negation(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn (1.0 - abs(1.0 - x - y)) * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_normal(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn y * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_overlay(const in float x, const in float y) {\n\n\treturn (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));\n\n}\n\nvec4 lamina_blend_overlay(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_overlay(x.r, y.r),\n\t\tlamina_blend_overlay(x.g, y.g),\n\t\tlamina_blend_overlay(x.b, y.b),\n\t\tlamina_blend_overlay(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_reflect(const in float x, const in float y) {\n\n\treturn (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);\n\n}\n\nvec4 lamina_blend_reflect(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_reflect(x.r, y.r),\n\t\tlamina_blend_reflect(x.g, y.g),\n\t\tlamina_blend_reflect(x.b, y.b),\n\t\tlamina_blend_reflect(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_screen(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn (1.0 - (1.0 - x) * (1.0 - y)) * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_softlight(const in float x, const in float y) {\n\n\treturn (y < 0.5) ?\n\t\t(2.0 * x * y + x * x * (1.0 - 2.0 * y)) :\n\t\t(sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));\n\n}\n\nvec4 lamina_blend_softlight(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_softlight(x.r, y.r),\n\t\tlamina_blend_softlight(x.g, y.g),\n\t\tlamina_blend_softlight(x.b, y.b),\n\t\tlamina_blend_softlight(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_subtract(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn max(x + y - 1.0, 0.0) * opacity + x * (1.0 - opacity);\n\n}\n\n`;\n\nvar NoiseChunk = /* glsl */\n`\n\n// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n// Huge thanks to the creators of these algorithms\n\nfloat lamina_noise_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_perm(vec4 x){return lamina_noise_mod289(((x * 34.0) + 1.0) * x);}\nvec4 lamina_noise_permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 lamina_noise_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n\nfloat lamina_noise_white(vec2 p) {\n  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *\n               (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\nfloat lamina_noise_white(vec3 p) {\n  return lamina_noise_white(p.xy);\n}\n\n\nvec3 lamina_noise_fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\nfloat lamina_noise_perlin(vec3 P) {\n  vec3 Pi0 = floor(P);        // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P);        // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = lamina_noise_permute(lamina_noise_permute(ix) + iy);\n  vec4 ixy0 = lamina_noise_permute(ixy + iz0);\n  vec4 ixy1 = lamina_noise_permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = lamina_noise_fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),\n                 fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return lamina_normalize(2.2 * n_xyz);\n}\n\nfloat lamina_noise_simplex(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n  // Permutations\n  i = mod(i, 289.0);\n  vec4 p = lamina_noise_permute(lamina_noise_permute(lamina_noise_permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +\n                             vec4(0.0, i1.y, i2.y, 1.0)) +\n                    i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  // Gradients\n  // ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0 / 7.0; // N=7\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  // Normalise gradients\n  vec4 norm =\n      lamina_noise_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m =\n      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return lamina_normalize(42.0 *\n         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))));\n}\n\nvec3 lamina_noise_simplex3(vec3 x) {\n  float s = lamina_noise_simplex(vec3(x));\n  float s1 = lamina_noise_simplex(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));\n  float s2 = lamina_noise_simplex(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));\n  vec3 c = vec3(s, s1, s2);\n  return c;\n}\n\nvec3 lamina_noise_curl(vec3 p) {\n  const float e = .1;\n  vec3 dx = vec3(e, 0.0, 0.0);\n  vec3 dy = vec3(0.0, e, 0.0);\n  vec3 dz = vec3(0.0, 0.0, e);\n\n  vec3 p_x0 = lamina_noise_simplex3(p - dx);\n  vec3 p_x1 = lamina_noise_simplex3(p + dx);\n  vec3 p_y0 = lamina_noise_simplex3(p - dy);\n  vec3 p_y1 = lamina_noise_simplex3(p + dy);\n  vec3 p_z0 = lamina_noise_simplex3(p - dz);\n  vec3 p_z1 = lamina_noise_simplex3(p + dz);\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / (2.0 * e);\n  return normalize(vec3(x, y, z) * divisor);\n}\n\nvec3 lamina_permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 lamina_dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\n// From: https://github.com/Erkaman/glsl-worley\nfloat lamina_noise_worley(vec3 P) {\n  float jitter = 1.;\n  bool manhattanDistance = false; \n\n  float K = 0.142857142857; // 1/7\n  float Ko = 0.428571428571; // 1/2-K/2\n  float  K2 = 0.020408163265306; // 1/(7*7)\n  float Kz = 0.166666666667; // 1/6\n  float Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = lamina_permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = lamina_permute(p + Pi.y - 1.0);\n\tvec3 p2 = lamina_permute(p + Pi.y);\n\tvec3 p3 = lamina_permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = lamina_permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = lamina_permute(p1 + Pi.z);\n\tvec3 p13 = lamina_permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = lamina_permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = lamina_permute(p2 + Pi.z);\n\tvec3 p23 = lamina_permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = lamina_permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = lamina_permute(p3 + Pi.z);\n\tvec3 p33 = lamina_permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = lamina_dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 = lamina_dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = lamina_dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = lamina_dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = lamina_dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = lamina_dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = lamina_dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = lamina_dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = lamina_dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\n  vec2 F = sqrt(d11.xy);\n\treturn F.x; // F1, F2\n\n}\n\nfloat lamina_noise_swirl(vec3 position) {\n    float scale = 0.1;\n    float freq = 4. * scale;\n    float t = 1.;\n\n    vec3 pos = (position * scale) + lamina_noise_curl(position * 7. * scale);\n\n    float worley1 = 1. - lamina_noise_worley((pos * (freq * 2.)) +  (t * 2.));\n    float worley2 = 1. - lamina_noise_worley((pos * (freq * 4.)) +  (t * 4.));\n    float worley3 = 1. - lamina_noise_worley((pos * (freq * 8.)) +  (t * 8.));\n    float worley4 = 1. - lamina_noise_worley((pos * (freq * 16.)) +  (t * 16.));\n    \n    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;\n    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;\n    float fbm3 = worley3 * .75 + worley4 * .25;\n\n    vec3 curlWorleyFbm = vec3(fbm1, fbm2, fbm3);\n    float curlWorley = curlWorleyFbm.r * .625 + curlWorleyFbm.g * .25 + \n        curlWorleyFbm.b * .125;\n\n    return curlWorley;\n}\n  \n  \n`;\n\nvar HelpersChunk = /* glsl */\n`\n\nfloat lamina_map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat lamina_normalize(float v) { return lamina_map(v, -1.0, 1.0, 0.0, 1.0); }\n`;\n\nclass LayerMaterial extends CustomShaderMaterial {\n  constructor({\n    color,\n    alpha,\n    lighting,\n    layers,\n    name,\n    ...props\n  } = {}) {\n    super(ShadingTypes[lighting || 'basic'], undefined, undefined, undefined, props);\n    this.name = 'LayerMaterial';\n    this.layers = [];\n    this.baseColor = 'white';\n    this.alpha = 1;\n    this.lighting = 'basic';\n    this.baseColor = color || this.baseColor;\n    this.alpha = alpha != null ? alpha : this.alpha;\n    this.layers = layers || this.layers;\n    this.lighting = lighting || this.lighting;\n    this.name = name || this.name;\n    this.refresh();\n  }\n\n  genShaders() {\n    let vertexVariables = '';\n    let fragmentVariables = '';\n    let vertexShader = '';\n    let fragmentShader = '';\n    let uniforms = {};\n    this.layers.filter(l => l.visible).forEach(l => {\n      // l.buildShaders(l.constructor)\n      vertexVariables += l.vertexVariables + '\\n';\n      fragmentVariables += l.fragmentVariables + '\\n';\n      vertexShader += l.vertexShader + '\\n';\n      fragmentShader += l.fragmentShader + '\\n';\n      uniforms = { ...uniforms,\n        ...l.uniforms\n      };\n    });\n    uniforms = { ...uniforms,\n      ...{\n        u_lamina_color: {\n          value: typeof this.baseColor === 'string' ? new THREE.Color(this.baseColor).convertSRGBToLinear() : this.baseColor\n        },\n        u_lamina_alpha: {\n          value: this.alpha\n        }\n      }\n    };\n    this.transparent = Boolean(this.alpha !== undefined && this.alpha < 1);\n    return {\n      uniforms,\n      vertexShader: `\n        ${HelpersChunk}\n        ${NoiseChunk}\n        ${vertexVariables}\n\n        void main() {\n          vec3 lamina_finalPosition = position;\n          vec3 lamina_finalNormal = normal;\n\n          ${vertexShader}\n\n          csm_Position = lamina_finalPosition;\n          csm_Normal = lamina_finalNormal;\n        }\n        `,\n      fragmentShader: `\n        ${HelpersChunk}\n        ${NoiseChunk}\n        ${BlendModesChunk}\n        ${fragmentVariables}\n\n        uniform vec3 u_lamina_color;\n        uniform float u_lamina_alpha;\n\n        void main() {\n          vec4 lamina_finalColor = vec4(u_lamina_color, u_lamina_alpha);\n\n          ${fragmentShader}\n\n          csm_DiffuseColor = lamina_finalColor;\n         \n        }\n        `\n    };\n  }\n\n  refresh() {\n    const {\n      uniforms,\n      fragmentShader,\n      vertexShader\n    } = this.genShaders();\n    super.update(fragmentShader, vertexShader, uniforms);\n  }\n\n  serialize() {\n    return {\n      constructor: 'LayerMaterial',\n      properties: {\n        color: this.baseColor,\n        alpha: this.alpha,\n        name: this.name,\n        lighting: this.lighting\n      }\n    };\n  }\n\n}\n\nexport { Abstract, Color, Depth, Displace, Fresnel, Gradient, LayerMaterial, Matcap, Noise, Normal, Texture };\n","/* jshint esversion: 9 */\n/* For dealing with spline curves */\n/* global THREE, AFRAME */\n\nimport { LayerMaterial } from 'lamina/vanilla';\nimport * as lamina from 'lamina/vanilla';\nconst kebabize = (str) => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? \"-\" : \"\") + $.toLowerCase())\n// const textureLoader = new THREE.TextureLoader();\nAFRAME.registerShader('lamina', {\n\tschema: {\n\t\tlayers: {\n\t\t\ttype: 'selector',\n\t\t\tdescription: 'Element that contains the layers, defautls to this element.'\n\t\t},\n\t\tcolor: {\n\t\t\ttype: 'color',\n\t\t\tdefault: 'white',\n\t\t\tdescription: 'Base color'\n\t\t},\n\t\talpha: {\n\t\t\tdefault: 1,\n\t\t\tdescription: 'Alpha'\n\t\t},\n\t\tlighting: {\n\t\t\toneOf: ['phong', 'physical', 'toon', 'basic', 'lambert', 'standard'],\n\t\t\tdefault: 'basic',\n\t\t\tdescription: 'Shading model to use.'\n\t\t}\n\t},\n\n\tinit: function (data) {\n\t\tconst layers = data.layers || this.el;\n\t\tthis.rendererSystem = this.el.sceneEl.systems.renderer;\n\t\tthis.material = new LayerMaterial({\n\t\t\tcolor: new THREE.Color(data.color).convertSRGBToLinear(),\n\t\t\tlayers: Array.from(layers.children).map(el => el.laminaLayer).filter(l => !!l),\n\t\t\tlighting: data.lighting\n\t\t});\n\t},\n\n\tupdate: function (data) {\n\t\tthis.material.color.set(data.color);\n\t\tthis.material.alpha = data.alpha;\n\t\tthis.material.lighting = data.lighting;\n\t\tthis.material.layers.splice(0);\n\t\tthis.material.needsUpdate = true;\n\t}\n});\n\nAFRAME.registerPrimitive('a-lamina', {\n\tmappings: {\n\t\tcolor: \"material.color\",\n\t\talpha: \"material.alpha\",\n\t\tlighting: \"material.lighting\",\n\t},\n\tdefaultComponents: {\n\t\tmaterial: \"shader:lamina;\"\n\t}\n});\n\nconst defaultSchema = {\n\tmode: {\n\t\tdefault: 'normal',\n\t\toneOf: [\n\t\t\t'normal',\n\t\t\t'divide',\n\t\t\t'add',\n\t\t\t'overlay',\n\t\t\t'subtract',\n\t\t\t'screen',\n\t\t\t'multiply',\n\t\t\t'softlight',\n\t\t\t'lighten',\n\t\t\t'reflect',\n\t\t\t'darken',\n\t\t\t'negation'\n\t\t]\n\t\t// blend mode\n\t},\n\tvisible: {\n\t\tdefault: true\n\t}\n};\n\nconst schemas = {};\nfor (const layer of [\n\t'Color',\n\t'Depth',\n\t'Fresnel',\n\t'Gradient',\n\t'Matcap',\n\t'Noise',\n\t'Normal',\n\t'Texture',\n\t'Displace'\n]) {\n\tconst schemaIn = new lamina[layer]().schema;\n\tconst schema = {};\n\tfor (const schemumIn of schemaIn) {\n\t\tconst schemum = Object.assign({}, schemumIn);\n\t\tif (!schemum.value && schemum.options) schemum.value = schemum.options[0];\n\t\tlet type = typeof schemum.value;\n\t\tif (type === \"object\") {\n\t\t\ttype = schemum.value.constructor.name;\n\t\t\tif (type === \"Vector3\") type = \"vec3\";\n\t\t\tif (type === \"Vector2\") type = \"vec1\";\n\t\t\tif (type === \"Matrix4\") type = \"mat4\";\n\t\t}\n\t\tif (schemum.label.startsWith('color')) {\n\t\t\ttype = 'color'\n\t\t}\n\t\tif (schemum.label.endsWith('Map') || schemum.label.endsWith('map')) {\n\t\t\ttype = 'map'\n\t\t}\n\t\tconst out = { type };\n\t\tif (schemum.value) out.default = schemum.value;\n\t\tif (schemum.options) out.oneOf = schemum.options;\n\t\tschema[schemum.label] = out;\n\t}\n\tschemas[layer] = schema;\n}\n\nfor (const [name, schemapart] of Object.entries(schemas)) {\n\tconst schema = Object.assign(Object.assign({}, defaultSchema), schemapart);\n\tAFRAME.registerComponent('lamina-' + name.toLowerCase(), {\n\t\tschema,\n\t\tinit() {\n\t\t\tconst config = {};\n\t\t\tconst self = this;\n\t\t\tfor (const [prop, value] of Object.entries(this.data)) {\n\t\t\t\tlet parsedVal = value;\n\t\t\t\tif (schema[prop].type === 'color') {\n\t\t\t\t\tparsedVal = new THREE.Color(value).convertSRGBToLinear();\n\t\t\t\t}\n\t\t\t\tif (schema[prop].type === 'map') {\n\t\t\t\t\tthis.el.sceneEl.systems.material.loadTexture(value, { src: value }, function textureLoaded (texture) {\n\t\t\t\t\t\tself.el.laminaLayer[prop] = texture;\n\t\t\t\t\t\tAFRAME.utils.material.handleTextureEvents(self.el, texture);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconfig[prop] = parsedVal;\n\t\t\t}\n\t\t\tconst layer = new lamina[name](config);\n\t\t\tthis.el.laminaLayer = layer;\n\t\t},\n\t\tupdate(oldData) {\n\t\t}\n\t})\n\t\n\tconst mappings = {};\n\tfor (const propName of Object.keys(schema)) {\n\t\tmappings[kebabize(propName)] = `${'lamina-' + name.toLowerCase()}.${propName}`\n\t}\n\tAFRAME.registerPrimitive('lamina-' + name.toLowerCase(), {\n\t\tmappings,\n\t\tdefaultComponents: {\n\t\t\t['lamina-' + name.toLowerCase()]: \"\"\n\t\t}\n\t})\n}\n"],"names":["literals","operators","builtins","literals300es","v100","slice","concat","require$$0","builtins300es","filter","b","test","glslTokenizer","opt","c","last","len","i","total","mode","NORMAL","content","tokens","line","col","start","isnum","isoperator","input","allBuiltins","builtins100","allLiterals","literals100","version","builtinsDict","literalsDict","length","data","chunk","toString","replace","block_comment","line_comment","preprocessor","operator","integer","hex","decimal","TOKEN","readtoken","whitespace","normal","write","token","join","end","push","type","map","position","column","determine_operator","is_composite_operator","buf","idx","res","j","indexOf","contentstr","string","str","generator","tokenize","glslTokenDepth","loop","depth","index","skipArrayArguments","glslTokenScope","stack","inc","ldepth","Error","splice","scope","glslTokenProperties","property","assignments","ignored","precision","highp","mediump","lowp","attribute","const","uniform","varying","break","continue","do","for","while","if","else","in","out","inout","true","false","return","glslTokenAssignments","assignment","declaration","skipWhitespace","datatype","ignoredKeywords","skipArrayDimensions","skipParens","structMember","n","glslTokenDescope_1","rename","require$$1","require$$2","require$$3","getScope","renamer","k","name","defaultRenamer","descoped","bound","s","glslTokenString","output","glslTokenFunctions","returnType","defnName","braceDepth","braceStart","defnStart","argFinish","argStart","findPrevious","findOp","findGlyph","body","args","outer","sort","a","match","bail","keywords","VERT","FRAG","CustomShaderMaterial","Material","constructor","baseMaterial","fragmentShader","vertexShader","uniforms","opts","base","super","this","key","undefined","update","generateMaterial","parsedFragmentShdaer","parseShader","parsedVertexShdaer","customProgramCacheKey","uuid","onBeforeCompile","shader","patchedFragmentShdaer","patchShader","patchedVertexShdaer","needsUpdate","customShader","patchMap","patchedShader","Object","keys","forEach","main","includes","replaceAll","header","defines","parsedShader","mainBody","rest","reduce","prev","curr","find","rep","split","getUniform","value","Color$1","getSpecialParameters","label","min","max","image","isSerializableType","prop","Vector3","Vector2","Vector4","Matrix3","Matrix4","serializeProp","toArray","clone","convertLinearToSRGB","getHexString","Texture$1","src","BlendModes","add","subtract","multiply","lighten","darken","divide","overlay","screen","softlight","negation","reflect","NoiseTypes","perlin","simplex","cell","curl","white","MappingTypes","local","world","uv","ShadingTypes","phong","THREE","MeshPhongMaterial","physical","MeshPhysicalMaterial","toon","MeshToonMaterial","basic","MeshBasicMaterial","lambert","MeshLambertMaterial","standard","MeshStandardMaterial","Abstract","props","onParse","MathUtils","generateUUID","visible","getOwnPropertyNames","e","startsWith","v","_Object$getOwnPropert","getOwnPropertyDescriptor","Color","propName","schema","properties","set","get","defineProperties","vertexVariables","fragmentVariables","buildShaders","options","values","_this$onParse","shaders","_Object$getOwnPropert2","vert","frag","descope","renameTokens","bind","funcs","tokenFunctions","mainIndex","variables","stringify","funcBodies","getShaderFromIndex","processFinal","call","_value","findIndex","obj","isVertex","returnValue","sReplaced","returnVariable","trim","blendMode","getBlendMode","getSchema","serialize","nonUniformPropKeys","nonUniformProps","Depth","self","mapping","getMapping","static","u_near","u_far","u_origin","u_colorA","u_colorB","u_alpha","u_color","Noise","noiseFunc","getNoiseFunction","u_colorC","u_colorD","u_scale","u_offset","Fresnel","u_bias","u_intensity","u_power","u_factor","Gradient","axes","u_start","u_end","u_contrast","Matcap","u_map","Texture","Displace","u_strength","Normal","u_direction","NoiseChunk","HelpersChunk","LayerMaterial","color","alpha","lighting","layers","baseColor","refresh","genShaders","l","u_lamina_color","convertSRGBToLinear","u_lamina_alpha","transparent","Boolean","AFRAME","registerShader","description","default","oneOf","init","el","rendererSystem","sceneEl","systems","renderer","material","Array","from","children","laminaLayer","registerPrimitive","mappings","defaultComponents","defaultSchema","schemas","layer","schemaIn","lamina","schemumIn","schemum","assign","endsWith","schemapart","entries","registerComponent","toLowerCase","config","parsedVal","loadTexture","texture","utils","handleTextureEvents","oldData","$","ofs"],"mappings":"oUAAAA,EAAiB,CAEb,YACA,QACA,UACA,OACA,YACA,QACA,UACA,UACA,QACA,WACA,KACA,MACA,QACA,KACA,OACA,KACA,MACA,QACA,QACA,MACA,OACA,OACA,OACA,OACA,QACA,UACA,SACA,OACA,OACA,OACA,OACA,OACA,OACA,QACA,QACA,QACA,QACA,QACA,QACA,YACA,YACA,YACA,cACA,kBACA,kBACA,SAGA,MACA,QACA,QACA,OACA,UACA,WACA,OACA,SACA,OACA,SACA,UACA,SACA,WACA,WACA,SACA,SACA,SACA,WACA,YACA,OACA,QACA,SACA,OACA,QACA,WACA,QACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,gBACA,gBACA,sBACA,SACA,OACA,YACA,SC5FJC,EAAiB,CACb,MACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KC7CJC,EAAiB,CAEf,MACE,OACA,MACA,MACA,OACA,OACA,OACA,QACA,MACA,QACA,OACA,OACA,UACA,WACA,MACA,QACA,MACA,OACA,cACA,QACA,QACA,eACA,2BACA,sBACA,kBACA,wBACA,eACA,gBACA,WACA,gBACA,0BACA,eACA,eACA,eACA,eACA,SACA,cACA,kBACA,mBACA,eACA,eACA,cACA,eACA,kBACA,gBACA,iBACA,4BACA,uBACA,mBACA,yBACA,gBACA,0BACA,wBACA,mBACA,iBACA,2BACA,wBACA,mBACA,kCACA,oBACA,kCACA,eACA,sBACA,0BACA,qBACA,sBACA,sBACA,gCACA,gCACA,qBACA,4BACA,qCACA,8BACA,+BACA,sCACA,+CACA,wCACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,oBACA,YACA,kBACA,iBACA,kBACA,kBACA,kBACA,kBACA,WACA,gBACA,qBACA,eACA,cACA,sBACA,6BACA,sCACA,+BACA,oBACA,cACA,qBACA,mBACA,0BACA,mCACA,4BACA,YACA,cACA,mBACA,cACA,SACA,WACA,gBACA,MACA,OACA,iBACA,MACA,MACA,MACA,MACA,YACA,MACA,WACA,MACA,UACA,UACA,UACA,OACA,MACA,aACA,OACA,OACA,MACA,YACA,eACA,gBACA,mBACA,cACA,iBACA,kBACA,sBACA,oBACA,mBACA,uBACA,sBClJJC,EAAiBC,EAAKC,QAAQC,OAAO,CAClC,SACC,WACA,SACA,OACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,QACA,QACA,QACA,oBACA,iBACA,uBACA,aACA,aACA,eACA,kBACA,aACA,aACA,eACA,kBACA,WACA,WACA,WACA,YACA,WACA,cACA,gBACA,QACA,SACA,aACA,SACA,YACA,SACA,SACA,UACA,UACA,UACA,YACA,WACA,WACA,WACA,aACA,WACA,WACA,WACA,aACA,eACA,eACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,qBACA,qBACA,cACA,eACA,eACA,iBACA,uBACA,aACA,kBACA,aACA,kBACA,iBACA,iBACA,gBACA,iBACA,iBACA,cACA,eACA,eACA,mBACA,oBACA,sBCpFAF,EAAOG,EAQXC,GAJAJ,EAAOA,EAAKC,QAAQI,QAAO,SAAUC,GACnC,OAAQ,kBAAkBC,KAAKD,OAGXJ,OAAO,CAEzB,cACA,gBACA,cACA,eACA,eACA,iBACA,eACA,gBACA,sBACA,6BACA,4BACA,6BACA,gCACA,kCACA,0BACA,+BACA,oBACA,2BACA,2BACA,0BACA,gBAGA,QACA,QACA,YACA,QACA,QACA,iBACA,kBACA,iBACA,kBACA,gBACA,kBACA,gBACA,kBACA,eACA,iBACA,eACA,YACA,cACA,UACA,UACA,cACA,cACA,aACA,gBACA,aACA,mBACA,oBACA,mBACA,iBACA,uBACA,cACA,oBACA,kBACA,0BCnEJM,EAsCA,SAAkBC,GAChB,IAGIC,EACAC,EAWAC,EAfAC,EAAI,EACJC,EAAQ,EACRC,EAAOC,EAGPC,EAAU,GACVC,EAAS,GAGTC,EAAO,EACPC,EAAM,EACNC,EAAQ,EACRC,GAAQ,EACRC,GAAa,EACbC,EAAQ,GAIRC,EAAcC,EACdC,EAAcC,EACE,YAHpBnB,EAAMA,GAAO,IAGLoB,UACNJ,EAAcrB,EACduB,EAAc5B,GAIhB,IAAI+B,EAAe,GAAIC,EAAe,GACtC,IAASlB,EAAI,EAAGA,EAAIY,EAAYO,OAAQnB,IACtCiB,EAAaL,EAAYZ,KAAM,EAEjC,IAASA,EAAI,EAAGA,EAAIc,EAAYK,OAAQnB,IACtCkB,EAAaJ,EAAYd,KAAM,EAGjC,OAAO,SAASoB,GAEd,OADAf,EAAS,GACI,OAATe,EAgBN,SAAeC,GACbrB,EAAI,EAEAqB,EAAMC,WAAUD,EAAQA,EAAMC,YAMlC,IAAIxB,EAJJa,GAASU,EAAME,QAAQ,QAAS,MAChCxB,EAAMY,EAAMQ,OAKZ,KAAMtB,EAAIc,EAAMX,GAAIA,EAAID,GAAK,CAG3B,OAFAD,EAAOE,EAEAE,GACL,KAhGY,EAgGQF,EAAIwB,IAAiB,MACzC,KAhGW,EAgGQxB,EAAIyB,IAAgB,MACvC,KAhGW,EAgGQzB,EAAI0B,IAAgB,MACvC,KAhGO,EAgGQ1B,EAAI2B,IAAY,MAC/B,KAhGM,EAgGQ3B,EAAI4B,IAAW,MAC7B,KA1FE,GA0FQ5B,EAAI6B,IAAO,MACrB,KAjGI,EAiGQ7B,EAAI8B,IAAW,MAC3B,KAAKC,EAAO/B,EAAIgC,IAAa,MAC7B,KA/FS,EA+FQhC,EAAIiC,IAAc,MACnC,KAAK9B,EAAQH,EAAIkC,IAGnB,GAAGpC,IAASE,EACV,GACO,OADAW,EAAMb,GACAS,EAAM,IAAKD,QACXC,EAOjB,OAFAN,GAASD,EACTW,EAAQA,EAAMvB,MAAMY,GACbK,EArDmB8B,CAAMf,GAwDlC,SAAaC,GACRjB,EAAQe,QACTiB,EAAMhC,EAAQiC,KAAK,KAKrB,OAFAnC,EApHM,GAqHNkC,EAAM,SACC/B,EA9DAiC,IAGT,SAASF,EAAMhB,GACTA,EAAKD,QACPd,EAAOkC,KAAK,CACVC,KAAMC,EAAIvC,GACVkB,KAAMA,EACNsB,SAAUlC,EACVF,KAAMA,EACNqC,OAAQpC,IAuDd,SAAS2B,IAGP,OAFA9B,EAAUA,EAAQe,OAAS,GAAKf,EAEpB,MAATN,GAAsB,MAAND,GACjBW,EAAQP,EAAQD,EAAI,EACpBE,EAxIc,EAyIdJ,EAAOD,EACAG,EAAI,GAGD,MAATF,GAAsB,MAAND,GACjBW,EAAQP,EAAQD,EAAI,EACpBE,EA9Ia,EA+IbJ,EAAOD,EACAG,EAAI,GAGJ,MAANH,GACDK,EAnJa,EAoJbM,EAAQP,EAAQD,EACTA,GAGN,KAAKN,KAAKG,IACXK,EAlJW,EAmJXM,EAAQP,EAAQD,EACTA,IAGTS,EAAQ,KAAKf,KAAKG,GAClBa,EAAa,SAAShB,KAAKG,GAE3BW,EAAQP,EAAQD,EAChBE,EAAOO,EAhKG,EAgKeC,EAjKd,EAiKsCqB,EAC1C/B,GAGT,SAASiC,IACP,MAAG,SAASvC,KAAKG,IACfuC,EAAMhC,EAAQiC,KAAK,KACnBnC,EAAOC,EACAH,IAETI,EAAQmC,KAAK1C,GACbC,EAAOD,EACAG,EAAI,GAGb,SAAS0B,IACP,MAAU,OAAN7B,GAAoB,OAANA,GAAwB,OAATC,GAKjCM,EAAQmC,KAAK1C,GACbC,EAAOD,EACAG,EAAI,IANToC,EAAMhC,EAAQiC,KAAK,KACnBnC,EAAOC,EACAH,GAOX,SAASyB,IACP,OAAOC,IAGT,SAASF,IACP,MAAS,MAAN3B,GAAsB,MAATC,GACdM,EAAQmC,KAAK1C,GACbuC,EAAMhC,EAAQiC,KAAK,KACnBnC,EAAOC,EACAH,EAAI,IAGbI,EAAQmC,KAAK1C,GACbC,EAAOD,EACAG,EAAI,GAGb,SAAS2B,IACP,GAAY,MAAT7B,GAAgB,KAAKJ,KAAKG,GAE3B,OADAK,EA5MM,EA6MCF,EAGT,GAAY,MAATF,GAAsB,MAAND,EAEjB,OADAK,EAtNc,EAuNPF,EAGT,GAAY,MAATF,GAAsB,MAAND,EAEjB,OADAK,EA1Na,EA2NNF,EAGT,GAAS,MAANH,GAAaO,EAAQe,OAAQ,CAC9B,KAAMyB,EAAmBxC,KAGzB,OADAF,EA7NM,EA8NCF,EAGT,GAAS,MAANH,GAAmB,MAANA,GAAmB,MAANA,EAAW,CACtC,GAAGO,EAAQe,OAAQ,KAAMyB,EAAmBxC,KAG5C,OAFAgC,EAAMvC,GACNK,EAAOC,EACAH,EAAI,EAGb,IAAI6C,EAA2C,IAAnBzC,EAAQe,QAAsB,MAANtB,EACpD,GAAG,YAAYH,KAAKG,IAAMgD,EAAuB,CAC/C,KAAMD,EAAmBxC,KAEzB,OADAF,EAAOC,EACAH,EAKT,OAFAI,EAAQmC,KAAK1C,GACbC,EAAOD,EACAG,EAAI,EAGb,SAAS4C,EAAmBE,GAK1B,IAJA,IACIC,EACAC,EAFAC,EAAI,IAIL,CAID,GAHAF,EAAM/D,EAAUkE,QAAQJ,EAAI1D,MAAM,EAAG0D,EAAI3B,OAAS8B,GAAGZ,KAAK,KAC1DW,EAAMhE,EAAU+D,IAEJ,IAATA,EAAY,CACb,GAAGE,IAAMH,EAAI3B,OAAS,EAAG,SACzB6B,EAAMF,EAAI1D,MAAM,EAAG,GAAGiD,KAAK,IAO7B,OAJAD,EAAMY,GAENxC,GAASwC,EAAI7B,QACbf,EAAUA,EAAQhB,MAAM4D,EAAI7B,SACbA,QAInB,SAASU,IACP,MAAG,eAAenC,KAAKG,IACrBuC,EAAMhC,EAAQiC,KAAK,KACnBnC,EAAOC,EACAH,IAGTI,EAAQmC,KAAK1C,GACbC,EAAOD,EACAG,EAAI,GAGb,SAAS4B,IACP,MAAS,MAAN/B,GAOA,OAAOH,KAAKG,IANbO,EAAQmC,KAAK1C,GACbK,EAzRM,EA0RNJ,EAAOD,EACAG,EAAI,GAUJ,MAANH,GAAgC,IAAnBO,EAAQe,QAA+B,MAAff,EAAQ,IAC9CF,EAhSI,GAiSJE,EAAQmC,KAAK1C,GACbC,EAAOD,EACAG,EAAI,GAGV,QAAQN,KAAKG,IACduC,EAAMhC,EAAQiC,KAAK,KACnBnC,EAAOC,EACAH,IAGTI,EAAQmC,KAAK1C,GACbC,EAAOD,EACAG,EAAI,GAGb,SAAS8B,IAOP,MANS,MAANjC,IACDO,EAAQmC,KAAK1C,GACbC,EAAOD,EACPG,GAAK,GAGJ,OAAON,KAAKG,IACbO,EAAQmC,KAAK1C,GACbC,EAAOD,EACAG,EAAI,IAGF,MAANH,GAAmB,MAANA,IAAc,OAAOH,KAAKI,KAMzC,QAAQJ,KAAKG,IACduC,EAAMhC,EAAQiC,KAAK,KACnBnC,EAAOC,EACAH,IARPI,EAAQmC,KAAK1C,GACbC,EAAOD,EACAG,EAAI,GAcf,SAASgC,IACP,GAAG,WAAWtC,KAAKG,GAAI,CACrB,IAAIsD,EAAa/C,EAAQiC,KAAK,IAU9B,OAREnC,EADCgB,EAAaiC,GArVR,EAuVElC,EAAakC,GAxVf,EADF,EA8VNf,EAAMhC,EAAQiC,KAAK,KACnBnC,EAAOC,EACAH,EAIT,OAFAI,EAAQmC,KAAK1C,GACbC,EAAOD,EACAG,EAAI,IA5WXG,EAAS,IACT4B,EAAQ,KAcRU,EAAM,CACN,gBACA,eACA,eACA,WACA,UACA,QACA,QACA,UACA,UACA,aACA,MACA,WCjCJ,IAAAW,EAEA,SAAwBC,EAAKzD,GAC3B,IAAI0D,EAAYC,EAAS3D,GACrBS,EAAS,GAKb,OAFAA,GADAA,EAASA,EAAOhB,OAAOiE,EAAUD,KACjBhE,OAAOiE,EAAU,QCTnC,IAAAE,EAEA,SAAuBnD,GAIrB,IAHA,IAAIoD,GAAQ,EACRC,EAAQ,EAEH1D,EAAI,EAAGA,EAAIK,EAAOc,OAAQnB,IAKjC,OAJAyD,EAAOA,GAA4B,YAAnBpD,EAAOL,GAAGwC,MACL,QAAnBnC,EAAOL,GAAGoB,KAGJf,EAAOL,GAAGoB,MAChB,IAAK,IAAKf,EAAOL,GAAG0D,MAAQD,EAAOC,IAAUA,EAAO,MACpD,IAAK,IAAKrD,EAAOL,GAAG0D,MAAQD,EAAOC,EAAQA,IAASD,GAAO,EAAO,MAClE,IAAK,IAAKpD,EAAOL,GAAG0D,QAAUA,EAAO,MACrC,QAAUrD,EAAOL,GAAG0D,MAAQA,EAIhC,IAAS1D,EAAI,EAAGA,EAAIK,EAAOc,OAAQnB,IAAK,CACtC,IAAIoC,EAAQ/B,EAAOL,GACf2D,EAAQ3D,EAAI,EAChB,IAAmB,UAAfoC,EAAMI,MAAmC,YAAfJ,EAAMI,QACpCoB,IAC2B,UAAvBvD,EAAOsD,GAAOnB,OAClBoB,IACAD,IAC2B,MAAvBtD,EAAOsD,GAAOvC,OAAlB,CAEA,KAAOf,EAAOsD,IAAiC,MAAvBtD,EAAOsD,GAAOvC,MAAuC,MAAvBf,EAAOsD,GAAOvC,MAClEf,EAAOsD,KAASD,QAEdrD,EAAOsD,IAAiC,MAAvBtD,EAAOsD,GAAOvC,MAAcf,EAAOsD,GAAOD,SAGjE,OAAOrD,EAEP,SAASuD,IACP,KAAOvD,EAAOsD,KACW,eAAvBtD,EAAOsD,GAAOnB,MACS,MAAvBnC,EAAOsD,GAAOvC,MACS,MAAvBf,EAAOsD,GAAOvC,MACS,YAAvBf,EAAOsD,GAAOvC,OACbuC,MC3CP,IAAAE,EAEA,SAAoBxD,GAClB,IAAIyD,EAAS,CAAC,GACVC,EAASD,EAAM,GACfE,EAAS,EAEb,IAAK3D,IAAWA,EAAOc,OAAQ,OAAOd,EACtC,KAAM,UAAWA,EAAO,IACtB,MAAM,IAAI4D,MAAM,kGAGlB,IAAK,IAAIjE,EAAI,EAAGA,EAAIK,EAAOc,OAAQnB,IAAK,CACtC,IAAIoC,EAAQ/B,EAAOL,GACf0D,EAAQtB,EAAMsB,MAEdA,EAAQM,EACVF,EAAMvB,OAAOwB,GAEXL,EAAQM,GACVF,EAAMI,QAAQ,EAAG,GAGnB9B,EAAM+B,MAAQL,EAAMA,EAAM3C,OAAS,GACnCiB,EAAM0B,MAAQA,EAAM1E,QACpB4E,EAAS5B,EAAMsB,MAGjB,OAAOrD,GC5BT,IAAA+D,EAEA,SAAoB/D,GAClB,IAAK,IAAIL,EAAI,EAAGA,EAAIK,EAAOc,OAAQnB,IAAK,CACtC,IAAIoC,EAAQ/B,EAAOL,GAGnB,GAFAoC,EAAMiC,UAAW,EAEE,UAAfjC,EAAMI,KAAV,CAGA,IADA,IAAIS,EAAIjD,EACDK,IAAS4C,IAAyB,eAAnB5C,EAAO4C,GAAGT,OAC3BnC,EAAO4C,IACW,aAAnB5C,EAAO4C,GAAGT,MACS,MAAnBnC,EAAO4C,GAAG7B,OAEdgB,EAAMiC,UAAW,IAGnB,OAAOhE,GClBT,IAAAiE,EAAiB,CACb,OAAO,EACP,OAAO,EACP,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,KAAK,GCbTC,EAAiB,CACbC,WAAa,EACbC,OAAS,EACTC,SAAW,EACXC,MAAQ,EACRC,WAAa,EACbC,OAAS,EACTC,SAAW,EACXC,SAAW,EACXC,OAAS,EACTC,UAAY,EACZC,IAAM,EACNC,KAAO,EACPC,OAAS,EACTC,IAAM,EACNC,MAAQ,EACRC,IAAM,EACNC,KAAO,EACPC,OAAS,EACTC,MAAQ,EACRC,OAAS,EACTC,QAAU,GClBdC,EAGA,SAAiBxF,GAMf,IALA,IAAI0C,EAAM,EAKD/C,EAAI,EAAGA,EAAIK,EAAOc,OAAQnB,IAAK,CACtC,IACIwC,GADAJ,EAAQ/B,EAAOL,IACDwC,KAElBJ,EAAM0D,YAAa,EACnB1D,EAAM2D,aAAc,EACP,UAATvD,GAA6B,YAATA,IACxBO,EAAM/C,EAAI,EAEVgG,IACyB,aAArB3F,EAAO0C,GAAKP,MACX8B,EAAYjE,EAAO0C,GAAK3B,QAC7BgB,EAAM0D,YAAa,IAarB,IAAS9F,EAAI,EAAGA,EAAIK,EAAOc,OAAQnB,IAAK,CACtC,IAAIiG,EAAW5F,EAAOL,GAElBoB,GADAoB,EAAWyD,EAASzD,KACTyD,EAAS7E,MAIxB,GAFA6E,EAASF,aAAc,EAEV,YAATvD,GACF,GAAI0D,EAAgB9E,GAAO,cAE7B,GAAa,UAAToB,EAAkB,SAKtB,GAHAO,EAAM/C,EAAI,EAEVmG,IACyB,UAArB9F,EAAO0C,GAAKP,KAKhB,GAJAnC,EAAO0C,KAAOgD,aAAc,EAC5BI,IAGyB,MAArB9F,EAAO0C,GAAK3B,KAAhB,CAuBA,KAAOf,EAAO0C,IAA6B,MAArB1C,EAAO0C,GAAK3B,MACP,MAArBf,EAAO0C,GAAK3B,MACd2B,IACAiD,KACI3F,EAAO0C,GAAKgD,YAAmC,UAArB1F,EAAO0C,GAAKP,OAAkBO,MAE5DiD,IACAI,IACAJ,IACAjD,KAIJ/C,EAAI+C,MApCJ,CAIE,IAHAA,IAEAiD,IACO3F,EAAO0C,IAA6B,MAArB1C,EAAO0C,GAAK3B,OACP,YAArBf,EAAO0C,GAAKP,MAA2C,UAArBnC,EAAO0C,GAAKP,OAClDO,IACAiD,IACyB,UAArB3F,EAAO0C,GAAKP,OAChBnC,EAAO0C,KAAOgD,aAAc,EAC5BC,IACAG,IACAH,IACyB,MAArB3F,EAAO0C,GAAK3B,OAChB2B,IACAiD,MAGFhG,EAAI+C,GA0BR,IAAS/C,EAAI,EAAGA,EAAIK,EAAOc,OAAQnB,IAAK,CACtC,IAAIoC,EACJ,GAAmB,aADfA,EAAQ/B,EAAOL,IACTwC,OACS,WAAfJ,EAAMhB,OACV2B,EAAM/C,EAAI,EACVgG,IACyB,UAArB3F,EAAO0C,GAAKP,OAEhBO,IACAiD,IAC2B,MAAvB3F,EAAO0C,KAAO3B,QAAlB,CAGA,IAFA4E,IAE4B,UAArB3F,EAAO0C,GAAKP,MAAyC,YAArBnC,EAAO0C,GAAKP,MAAoB,CACrE,GACEO,IACAiD,IACA3F,EAAO0C,GAAKsD,cAAe,EAC3BhG,EAAO0C,GAAKgD,aAAc,EAC1BhD,IACAoD,UAC4B,MAArB9F,EAAO0C,GAAK3B,MAEI,MAArBf,EAAO0C,GAAK3B,MAAc2B,IAC9BiD,IAKF,GAFAjD,IACAiD,IACyB,UAArB3F,EAAO0C,GAAKP,KAIhB,IAHAnC,EAAO0C,GAAKgD,aAAc,EAC1BC,IAE8B,MAAvB3F,IAAS0C,GAAK3B,MACnB4E,IACAjD,IACAiD,IACyB,UAArB3F,EAAO0C,GAAKP,OAAkBnC,EAAO0C,GAAKgD,aAAc,GAC5DC,KAIJ,OAAO3F,EAEP,SAAS2F,EAAeM,GACtB,KAAOjG,EAAO0C,IAA6B,eAArB1C,EAAO0C,GAAKP,MAAuBO,IAG3D,SAASoD,IACP,KAAO9F,EAAO0C,KACY,YAArB1C,EAAO0C,GAAKP,MACS,MAArBnC,EAAO0C,GAAK3B,MACS,MAArBf,EAAO0C,GAAK3B,MACS,eAArBf,EAAO0C,GAAKP,OACdO,IAGL,SAASqD,IACP,GAAK/F,EAAO0C,IACa,MAArB1C,EAAO0C,GAAK3B,KAAhB,CACA,IAAIsC,EAAQ,EAEZ,EAAG,CACD,GAAyB,MAArBrD,EAAO0C,GAAK3B,KAAc,MACL,MAArBf,EAAO0C,GAAK3B,MAAcsC,IACL,MAArBrD,EAAO0C,GAAK3B,MAAcsC,UACxBA,GAASrD,IAAS0C,OCvK9B,IAAAwD,EAEA,SAA0BlG,EAAQmG,GAChClH,EAA4Be,GAC5BoG,EAA4BpG,GAC5BqG,EAAiCrG,GACjCsG,EAAkCtG,GAMlC,IAJA,IAAI8D,EAkDN,SAAkB9D,GAGhB,IAFA,IAAI8D,EAAQ,GAEHnE,EAAI,EAAGA,EAAIK,EAAOc,OAAQnB,IAAK,CACtC,IAAIoC,EAAQ/B,EAAOL,GACfoC,EAAM2D,cACR5B,EAAM/B,EAAM+B,OAASA,EAAM/B,EAAM+B,QAAU,GAC3CA,EAAM/B,EAAM+B,OAAO/B,EAAMhB,MAAQgB,GAIrC,OAAO+B,EA7DOyC,CAASvG,GACnBwG,EAAUL,GAyChB,WACE,IAAIM,EAAI,EAER,OAAO,SAAgBC,GACrB,OAAOA,EAAO,KAAOD,KAAKxF,SAAS,KA7Cb0F,GACpBvE,EAAU,GAELzC,EAAI,EAAGA,EAAIK,EAAOc,OAAQnB,IAAK,CACtC,IAAIoC,EAAQ/B,EAAOL,GACf8D,EAAQ1B,EAAM0B,MACdiD,EAAQ3E,EAAMhB,KAIlB,GAFAgB,EAAM6E,UAAW,EAEE,UAAf7E,EAAMI,OACNJ,EAAMiC,WACNjC,EAAMiE,aAAV,CAIA,IAFA,IAAIa,GAAQ,EAEHjE,EAAIa,EAAM3C,OAAS,EAAG8B,GAAK,EAAGA,IAAK,CAC1C,IAAIkE,EAAIhD,EAAML,EAAMb,IACpB,GAAKkE,GACAA,EAAEJ,GAAP,CAKA,GAHAG,GAAQ,EAGJjE,EAAG,MAEPb,EAAM6E,SAAW7E,EAAMhB,KACvBgB,EAAMhB,KAAOqB,EAAIsE,GAAQtE,EAAIsE,IAASF,EAAQE,EAAM3E,IAAUA,EAAMhB,MAKjE8F,IACH9E,EAAM6E,SAAW7E,EAAMhB,KACvBgB,EAAMhB,KAAOqB,EAAIsE,GAAQtE,EAAIsE,IAASF,EAAQE,EAAM3E,IAAUA,EAAMhB,OAIxE,OAAOf,GC/CT,IAAA+G,EAEA,SAAkB/G,GAGhB,IAFA,IAAIgH,EAAS,GAEJrH,EAAI,EAAGA,EAAIK,EAAOc,OAAQnB,IACV,QAAnBK,EAAOL,GAAGwC,MACd6E,EAAO9E,KAAKlC,EAAOL,GAAGoB,MAGxB,OAAOiG,EAAOhF,KAAK,KCVrB,IAAAiF,EAEA,SAAoBjH,GAClB,IAQIL,EAAGiD,EAAGb,EARNmF,EAAa,KACbC,EAAW,KACXC,EAAa,EACbC,EAAa,EACbC,EAAY,EACZC,EAAY,EACZC,EAAW,EACXR,EAAS,GAQb,IAAKrH,EAAI,EAAMA,EAAIK,EAAOc,OAAQnB,IAEhC,GAAmB,OADnBoC,EAAQ/B,EAAOL,IACLoB,KAAc,CAEtB,GAAIqG,GAAcA,IAAc,SAMhC,IADAxE,EAAI6E,EAAa9H,EAAG+H,EAAO,KAAMA,MACzB,EAAG,SAMX,GALAH,EAAY3E,GAIZA,EAAI6E,EAAa7E,EAAG8E,EAAO,KAAMA,EAAO,OAChC,EAAG,SAOX,GANAF,EAAW5E,GAKXA,EAAI6E,EAAa7E,EAAG+E,IACZ,EAAG,SACX,GAAuB,UAAnB3H,EAAO4C,GAAGT,KAAkB,SAMhC,GALAgF,EAAWnH,EAAO4C,GAAG7B,MAIrB6B,EAAI6E,EAAa7E,EAAG+E,IACZ,EAAG,SAEXP,EAAa,EACbC,EAAa1H,EACbuH,EAAalH,EAAO4C,GAAG7B,KACvBuG,EAAY1E,EAMZ,IAAI6D,EAAIgB,EAAa7E,EAAG+E,GACxB,OAAQ3H,EAAOyG,IAAMzG,EAAOyG,GAAG1F,MAC7B,IAAK,OACL,IAAK,QACL,IAAK,UACHuG,EAAYb,QAGlB,GAAIW,GAA6B,MAAfrF,EAAMhB,KAAc,CACpC,KAAMqG,EAAY,SAElBJ,EAAO9E,KAAK,CACVwE,KAAMS,EACNhF,KAAM+E,EACNU,KAAM,CAACP,EAAa,EAAG1H,GACvBkI,KAAM,CAACL,EAAUD,EAAY,GAC7BO,MAAO,CAACR,EAAW3H,EAAI,KAU7B,IAAKA,EAAI,EAAGA,EAAIK,EAAOc,OAAQnB,IAE7B,GAAmB,OADnBoC,EAAQ/B,EAAOL,IACLoB,KAAc,CAItB,IADA6B,EAAI6E,EAAa9H,EAAG+H,EAAO,KAAMA,MACzB,EAAG,SAGX,GAFAH,EAAY3E,GACZA,EAAI6E,EAAa7E,EAAG8E,EAAO,KAAMA,EAAO,OAChC,EAAG,SAGX,GAFAF,EAAW5E,GACXA,EAAI6E,EAAa7E,EAAG+E,IACZ,EAAG,SACX,GAAuB,UAAnB3H,EAAO4C,GAAGT,KAAkB,SAMhC,GALAgF,EAAWnH,EAAO4C,GAAG7B,MAIrB6B,EAAI6E,EAAa7E,EAAG+E,IACZ,EAAG,SACX,GAAuB,aAAnB3H,EAAO4C,GAAGT,KAAqB,SACnC,GAAuB,WAAnBnC,EAAO4C,GAAG7B,KAAmB,SACjCmG,EAAalH,EAAO4C,GAAG7B,KAEvBiG,EAAO9E,KAAK,CACVwE,KAAMS,EACNhF,KAAM+E,EACNU,MAAM,EACNC,KAAM,CAACL,EAAUD,EAAY,GAC7BO,MAAO,CAAClF,EAAGjD,EAAI,KAKrB,OAAOqH,EAAOe,MAAK,SAAUC,EAAG5I,GAC9B,OAAO4I,EAAEF,MAAM,GAAK1I,EAAE0I,MAAM,MAG9B,SAASL,EAActH,EAAO8H,EAAOC,GACnC,IAAK,IAAIvI,EAAIQ,EAAQ,EAAGR,GAAK,EAAGA,IAAK,CACnC,GAAIsI,EAAMjI,EAAOL,IAAK,OAAOA,EAC7B,GAAIuI,GAAQA,EAAKlI,EAAOL,IAAK,OAAQ,EAGvC,OAAQ,IAIZ,SAAS+H,EAAQ3G,GACf,OAAO,SAAUgB,GACf,MAAsB,aAAfA,EAAMI,QAAyBpB,GAAQgB,EAAMhB,OAASA,IAIjE,SAAS4G,EAAW5F,GAClB,MAAsB,eAAfA,EAAMI,KC1If,IAAIgG,EACO,eADPA,EAEQ,eAFRA,EAGM,aAHNA,EAIS,gBAJTA,EAKY,mBALZA,EAMS,gBAGb,MAAMC,EAAO,CACX,CAAC,GAAGD,KAAoB,CACtB,kCAAmC,kCACRA,wtBAoB7B,CAAC,GAAGA,KAAqB,CACvB,4BAA6B,uBACbA,yCAIlB,CAAC,GAAGA,KAAuB,CACzB,uBAAwB,kBAAkBA,OAGxCE,EAAO,CACX,CAAC,GAAGF,KAA0B,CAC5B,4BAA6B,uDAEZA,UAGnB,CAAC,GAAGA,KAAuB,CACzB,6BAA8B,yDAEZA,UAGpB,CAAC,GAAGA,KAAsB,CACxB,yCAA0C,sCACXA,aAKnC,MAAMG,UAA6BC,EAAAA,SACjCC,YAAYC,EAAcC,EAAgBC,EAAcC,EAAUC,GAEhE,MAAMC,EAAO,IAAIL,EAAaI,GAC9BE,QACAC,KAAKF,KAAOA,EACZE,KAAKJ,SAAWA,GAAY,GAE5B,IAAK,MAAMK,KAAOD,KAAKF,UAEHI,IAAdF,KAAKC,KAAoBD,KAAKC,GAAO,GAEzCD,KAAKC,GAAOD,KAAKF,KAAKG,GAGxBD,KAAKG,OAAOT,EAAgBC,EAAcC,GAG5CO,OAAOT,EAAgBC,EAAcC,GACnCI,KAAKI,iBAAiBV,EAAgBC,EAAcC,GAGtDQ,iBAAiBV,EAAgBC,EAAcC,GAC7C,MAAMS,EAAuBL,KAAKM,YAAYZ,GACxCa,EAAqBP,KAAKM,YAAYX,GAC5CK,KAAKJ,SAAWA,GAAY,GAE5BI,KAAKQ,sBAAwB,IACpBR,KAAKS,KAGdT,KAAKU,gBAAkBC,IACrB,GAAIN,EAAsB,CACxB,MAAMO,EAAwBZ,KAAKa,YAAYR,EAAsBM,EAAOjB,eAAgBL,GAC5FsB,EAAOjB,eAAiBkB,EAG1B,GAAIL,EAAoB,CACtB,MAAMO,EAAsBd,KAAKa,YAAYN,EAAoBI,EAAOhB,aAAcP,GACtFuB,EAAOhB,aAAe,uBAAyBmB,EAGjDH,EAAOf,SAAW,IAAKe,EAAOf,YACzBI,KAAKJ,UAEVI,KAAKJ,SAAWe,EAAOf,SACvBI,KAAKe,aAAc,GAIvBF,YAAYG,EAAcL,EAAQM,GAChC,IAAIC,EAAgBP,EAoCpB,OAnCAQ,OAAOC,KAAKH,GAAUI,SAAQ3D,IAC5ByD,OAAOC,KAAKH,EAASvD,IAAO2D,SAAQpB,IAC9Be,EAAaM,KAAKC,SAAS7D,KAC7BwD,EAAgBM,EAAWN,EAAejB,EAAKgB,EAASvD,GAAMuC,WAIpEiB,EAAgBA,EAAchJ,QAAQ,gBAAiB,eAC/C8I,EAAaS,goBAwBXT,EAAaM,oBAEvBJ,EAAgBF,EAAaU,QAAUR,EAChCA,EAGTZ,YAAYK,GACV,IAAKA,EAAQ,OACb,MAAMgB,EAAe,CACnBD,QAAS,GACTD,OAAQ,GACRH,KAAM,IAEFA,EAAOX,EAAO1B,MAAM,oDAE1B,GAAY,MAARqC,GAAgBA,EAAKxJ,OAAQ,CAC/B,MAAM8J,EAAWN,EAAK,GAAGrC,MAAM,mBAEf,MAAZ2C,GAAoBA,EAAS9J,SAC/B6J,EAAaL,KAAOM,EAAS,IAG/B,MAAMC,EAAOlB,EAAOzI,QAAQoJ,EAAK,GAAI,IAC/BI,EAAUG,EAAK5C,MAAM,aAAe,GACpCwC,EAASC,EAAQI,QAAO,CAACC,EAAMC,IAASD,EAAK7J,QAAQ8J,EAAM,KAAKH,GACtEF,EAAaF,OAASA,EACtBE,EAAaD,QAAUA,EAAQ1I,KAAK,MAGtC,OAAO2I,GAKX,MAAMH,EAAa,CAACxH,EAAKiI,EAAMC,IAAQlI,EAAImI,MAAMF,GAAMjJ,KAAKkJ,GC9K5D,SAASE,EAAWC,GAClB,MAAqB,iBAAVA,EACF,IAAIC,EAAAA,MAAQD,GAGdA,EAET,SAASE,EAAqBC,GAC5B,OAAQA,GACN,IAAK,QACH,MAAO,CACLC,IAAK,EACLC,IAAK,GAGT,IAAK,QACH,MAAO,CACLD,IAAK,GAGT,IAAK,MACH,MAAO,CACLE,WAAOzC,GAGX,QACE,MAAO,IAGb,SAAS0C,EAAmBC,GAC1B,OAAOA,aAAgBC,EAAAA,SAAWD,aAAgBE,WAAWF,aAAgBG,EAAOA,SAAIH,aAAgBI,EAAAA,SAAWJ,aAAgBK,UAErI,SAASC,EAAcN,GACrB,OAAID,EAAmBC,GACdA,EAAKO,UACHP,aAAgBP,QAClB,IAAMO,EAAKQ,QAAQC,sBAAsBC,eACvCV,aAAgBW,UAClBX,EAAKF,MAAMc,IAGbZ,EAGT,MAAMa,EAAa,CACjB7K,OAAQ,SACR8K,IAAK,MACLC,SAAU,WACVC,SAAU,WACVC,QAAS,UACTC,OAAQ,SACRC,OAAQ,SACRC,QAAS,UACTC,OAAQ,SACRC,UAAW,YACXC,SAAU,WACVC,QAAS,WAELC,EAAa,CACjBC,OAAQ,SACRC,QAAS,UACTC,KAAM,OACNC,KAAM,OACNC,MAAO,SAEHC,EAAe,CACnBC,MAAO,QACPC,MAAO,QACPC,GAAI,MAEAC,EAAe,CACnBC,MAAOC,EAAMC,kBACbC,SAAUF,EAAMG,qBAChBC,KAAMJ,EAAMK,iBACZC,MAAON,EAAMO,kBACbC,QAASR,EAAMS,oBACfC,SAAUV,EAAMW,sBAGlB,MAAMC,EACJtG,YAAYhJ,EAAGuP,EAAOC,GACpBhG,KAAKS,KAAOwF,YAAUC,eAAehO,QAAQ,KAAM,KACnD8H,KAAKtC,KAAO,gBACZsC,KAAKnJ,KAAO,SACZmJ,KAAKmG,SAAU,EACf,MACMvG,EADWuB,OAAOiF,oBAAoB5P,GAAGL,QAAOkQ,GAAKA,EAAEC,WAAW,QAC9CxE,QAAO,CAAC9C,EAAGuH,KACnC,IAAIC,EAEJ,IAAInE,EAA2E,OAAlEmE,EAAwBrF,OAAOsF,yBAAyBjQ,EAAG+P,SAAc,EAASC,EAAsBnE,MAErH,OADIO,EAAmBP,IAAUA,aAAiBC,EAAOoE,SAAErE,EAAQA,EAAMgB,SAClE,IAAKrE,EACV,CAACuH,EAAExQ,MAAM,IAAKsM,KAEf,IAEH,IAAK,MAAMpC,KAAOL,EAAU,CAC1B,MAAM+G,EAAW1G,EAAIkC,MAAM,KAAK,QACmBjC,KAArC,MAAT6F,OAAgB,EAASA,EAAMY,MAA0B/G,EAASK,GAAO8F,EAAMY,IAGlFZ,GACF5E,OAAOC,KAAK2E,GAAO3M,KAAI6G,SACFC,IAAf6F,EAAM9F,KAERD,KAAKC,GAAO8F,EAAM9F,OAKxBD,KAAKJ,SAAW,GAChBI,KAAK4G,OAAS,GACd,MAAMC,EAAa,GACnB1F,OAAOC,KAAKxB,GAAUxG,KAAI6G,IACxB,MAAM0G,EAAW1G,EAAIkC,MAAM,KAAK,GAChCnC,KAAKJ,SAAS,KAAKI,KAAKS,QAAQkG,KAAc,CAC5CtE,MAAOD,EAAWxC,EAASK,KAE7BD,KAAK4G,OAAO1N,KAAK,CACfmJ,MAAOzC,EAASK,GAChBuC,MAAOmE,IAETE,EAAWF,GAAY,CACrBG,IAAKP,IACHvG,KAAKJ,SAAS,KAAKI,KAAKS,QAAQkG,KAAYtE,MAAQD,EAAWmE,IAEjEQ,IAAK,IACI/G,KAAKJ,SAAS,KAAKI,KAAKS,QAAQkG,KAAYtE,UAI5C,MAAT0D,GAAiBA,EAAMrI,OAAMsC,KAAKtC,KAAOqI,EAAMrI,MACtC,MAATqI,GAAiBA,EAAMlP,OAAMmJ,KAAKnJ,KAAOkP,EAAMlP,MACtC,MAATkP,GAAiBA,EAAMI,UAASnG,KAAKmG,QAAUJ,EAAMI,SACzDhF,OAAO6F,iBAAiBhH,KAAM6G,GAC9B7G,KAAKL,aAAe,GACpBK,KAAKN,eAAiB,GACtBM,KAAKiH,gBAAkB,GACvBjH,KAAKkH,kBAAoB,GACzBlH,KAAKgG,QAAUA,EACfhG,KAAKmH,aAAa3Q,GAOlBwJ,KAAK4G,OAAO1N,KAAK,CACfmJ,MAAOrC,KAAKnJ,KACZ2L,MAAO,OACP4E,QAASjG,OAAOkG,OAAO3D,KAEzB1D,KAAK4G,OAAO1N,KAAK,CACfmJ,MAAOrC,KAAKmG,QACZ3D,MAAO,YAIX2E,aAAa3H,GACX,IAAI8H,EAEJ,MAAMC,EAAUpG,OAAOiF,oBAAoB5G,GAAarJ,QAAOkQ,GAAW,mBAANA,GAAgC,iBAANA,IAAsBvE,QAAO,CAAC9C,EAAGuH,KAC7H,IAAIiB,EAEJ,MAAO,IAAKxI,EACVuH,CAACA,GAAkF,OAA7EiB,EAAyBrG,OAAOsF,yBAAyBjH,EAAa+G,SAAc,EAASiB,EAAuBnF,SAE3H,IACGrL,EAAS,CACbyQ,KAAMvN,EAASqN,EAAQ5H,cAAgB,IACvC+H,KAAMxN,EAASqN,EAAQ7H,gBAAkB,KAErC9B,EAAW,CACf6J,KAAME,EAAQ3Q,EAAOyQ,KAAMzH,KAAK4H,aAAaC,KAAK7H,OAClD0H,KAAMC,EAAQ3Q,EAAO0Q,KAAM1H,KAAK4H,aAAaC,KAAK7H,QAE9C8H,EAAQ,CACZL,KAAMM,EAAenK,EAAS6J,MAC9BC,KAAMK,EAAenK,EAAS8J,OAE1BM,EACEF,EAAML,KAAKrO,KAAIiN,GACZA,EAAE3I,OACR7D,QAAQ,QAHPmO,EAIEF,EAAMJ,KAAKtO,KAAIiN,GACZA,EAAE3I,OACR7D,QAAQ,QAEPoO,EAAY,CAChBR,KAAMO,GAAkB,EAAIE,EAAUtK,EAAS6J,KAAK1R,MAAM,EAAG+R,EAAML,KAAKO,GAAgBlJ,MAAM,KAAO,GACrG4I,KAAMM,GAAkB,EAAIE,EAAUtK,EAAS8J,KAAK3R,MAAM,EAAG+R,EAAMJ,KAAKM,GAAgBlJ,MAAM,KAAO,IAEjGqJ,EAAa,CACjBV,KAAMO,GAAkB,EAAIhI,KAAKoI,mBAAmBxK,EAAS6J,KAAMK,EAAML,KAAKO,GAAgBpJ,MAAQ,GACtG8I,KAAMM,GAAkB,EAAIhI,KAAKoI,mBAAmBxK,EAAS8J,KAAMI,EAAMJ,KAAKM,GAAgBpJ,MAAQ,IAExGoB,KAAKL,aAAeK,KAAKqI,aAAaF,EAAWV,MAAM,GACvDzH,KAAKN,eAAiBM,KAAKqI,aAAaF,EAAWT,MACnD1H,KAAKiH,gBAAkBgB,EAAUR,KACjCzH,KAAKkH,kBAAoBe,EAAUP,KACD,OAAjCJ,EAAgBtH,KAAKgG,UAA4BsB,EAAcgB,KAAKtI,KAAMA,MAC3EA,KAAK4G,OAAS5G,KAAK4G,OAAOzQ,QAAO,CAACkM,EAAO/H,KACvC,MAAMiO,EAASlG,EAAMG,MACrB,OAAOlI,IAAU0F,KAAK4G,OAAO4B,WAAUC,GAC9BA,EAAIjG,QAAU+F,OAK3BX,aAAalK,GACX,GAAIA,EAAK4I,WAAW,MAAO,CACzB,MAAMvQ,EAAQ2H,EAAK3H,MAAM,GACzB,MAAO,KAAKiK,KAAKS,QAAQ1K,IACpB,GAAI2H,EAAK4I,WAAW,MAAO,CAChC,MAAMvQ,EAAQ2H,EAAK3H,MAAM,GACzB,MAAO,KAAKiK,KAAKS,QAAQ1K,IACpB,GAAI2H,EAAK4I,WAAW,MAAO,CAChC,MAAMvQ,EAAQ2H,EAAK3H,MAAM,GACzB,MAAO,KAAKiK,KAAKS,QAAQ1K,IAEzB,OAAO2H,EAIX2K,aAAa1H,EAAQ+H,GACnB,MAAM5K,EAAI6C,EAAOzI,QAAQ,SAAU,MAAM8H,KAAKS,SAASvI,QAAQ,SAAU,MAAM8H,KAAKS,SAC9EkI,EAAc7K,EAAEmB,MAAM,kBAC5B,IAAI2J,EAAY9K,EAAE5F,QAAQ,iBAAkB,IAE5C,GAAmB,MAAfyQ,GAAuBA,EAAY,GAAI,CACzC,MAAME,EAAiBF,EAAY,GAAGzQ,QAAQ,SAAU,IAAI4Q,OAAO5Q,QAAQ,IAAK,IAC1E6Q,EAAY/I,KAAKgJ,aAAaH,EAAgB,qBACpDD,GAAaF,EAAW,0BAA0BG,KAAoB,uBAAuBE,KAG/F,OAAOH,EAGTR,mBAAmBpR,EAAQsD,GACzB,OAAO4N,EAAUlR,EAAOjB,MAAMuE,EAAM,GAAIA,EAAM,KAGhD0O,aAAa5S,EAAG4I,GACd,OAAQgB,KAAKnJ,MACX,QACA,IAAK,SACH,MAAO,sBAAsBmI,MAAM5I,MAAMA,OAE3C,IAAK,MACH,MAAO,oBAAoB4I,MAAM5I,MAAMA,OAEzC,IAAK,WACH,MAAO,yBAAyB4I,MAAM5I,MAAMA,OAE9C,IAAK,WACH,MAAO,yBAAyB4I,MAAM5I,MAAMA,OAE9C,IAAK,UACH,MAAO,wBAAwB4I,MAAM5I,MAAMA,OAE7C,IAAK,SACH,MAAO,uBAAuB4I,MAAM5I,MAAMA,OAE5C,IAAK,SACH,MAAO,uBAAuB4I,MAAM5I,MAAMA,OAE5C,IAAK,UACH,MAAO,wBAAwB4I,MAAM5I,MAAMA,OAE7C,IAAK,SACH,MAAO,uBAAuB4I,MAAM5I,MAAMA,OAE5C,IAAK,YACH,MAAO,0BAA0B4I,MAAM5I,MAAMA,OAE/C,IAAK,UACH,MAAO,wBAAwB4I,MAAM5I,MAAMA,OAE7C,IAAK,WACH,MAAO,yBAAyB4I,MAAM5I,MAAMA,QAIlD6S,YAeE,OAdqBjJ,KAAK4G,OAAOxN,KAAI,EACnCoJ,MAAAA,EACA4E,QAAAA,KACGvF,MAEI,CACLW,MAAAA,EACA4E,QAAAA,KACG7E,EAAqBC,MACrBX,EAEHQ,MAAOc,EAAcnD,KAAKwC,QAMhC0G,YACE,MAAMxL,EAAOsC,KAAKR,YAAY9B,KAAKyE,MAAM,KAAK,GAC9C,IAAIgH,EAAqBhI,OAAOC,KAAKpB,MACrCmJ,EAAqBA,EAAmBhT,QAAOkQ,IAAM,CAAC,OAAQ,WAAY,SAAU,iBAAkB,eAAgB,oBAAqB,kBAAmB,UAAW,SAAU,QAAS,WAAW9E,SAAS8E,KAChN,MAAM+C,EAAkB,GACxBD,EAAmB9H,SAAQ5D,IAEzB2L,EAAgB3L,GAAKuC,KAAKvC,MAE5B,MAAMsI,EAAQ,GAEd,IAAK,MAAM9F,KAAOD,KAAKJ,SAAU,CAE/BmG,EADa9F,EAAI/H,QAAQ,KAAK8H,KAAKS,QAAS,KAC9B0C,EAAcnD,KAAKJ,SAASK,GAAKoC,OAGjD,MAAO,CACL7C,YAAa9B,EACbmJ,WAAY,IAAKd,KACZqD,KAOX,MAAMC,UAAcvD,EAClBtG,YAAYuG,GACVhG,MAAMsJ,EAAO,CACX3L,KAAM,WACHqI,IACFuD,IACDA,EAAK1C,OAAO1N,KAAK,CACfmJ,MAAOiH,EAAKC,QACZ/G,MAAO,UACP4E,QAAS,CAAC,SAAU,QAAS,YAE/B,MAAMmC,EAAUF,EAAMG,WAAWF,EAAK7I,KAAM6I,EAAKC,SACjDD,EAAK5J,eAAiB4J,EAAK5J,eAAexH,QAAQ,0BAA2BqR,MAE/EvJ,KAAKuJ,QAAU,SAGjBE,kBAAkBhJ,EAAMtH,GACtB,OAAQA,GACN,QACA,IAAK,SACH,MAAO,YAAYsH,uBAA0BA,YAE/C,IAAK,QACH,MAAO,YAAYA,yBAErB,IAAK,SACH,MAAO,YAAYA,sCAK3B4I,EAAMK,OAAS,EACfL,EAAMM,MAAQ,GACdN,EAAMO,SAAW,IAAI9G,EAAOA,QAAC,EAAG,EAAG,GACnCuG,EAAMQ,SAAW,QACjBR,EAAMS,SAAW,QACjBT,EAAMU,QAAU,EAChBV,EAAM1J,aAAe,wLASrB0J,EAAM3J,eAAiB,+hBAsBvB,MAAMgH,UAAcZ,EAClBtG,YAAYuG,GACVhG,MAAM2G,EAAO,CACXhJ,KAAM,WACHqI,KAKTW,EAAMsD,QAAU,MAChBtD,EAAMqD,QAAU,EAChBrD,EAAMhH,eAAiB,mIASvB,MAAMuK,UAAcnE,EAClBtG,YAAYuG,GACVhG,MAAMkK,EAAO,CACXvM,KAAM,WACHqI,IACFuD,IACDA,EAAK1C,OAAO1N,KAAK,CACfmJ,MAAOiH,EAAKnQ,KACZqJ,MAAO,OACP4E,QAASjG,OAAOkG,OAAO/C,KAEzBgF,EAAK1C,OAAO1N,KAAK,CACfmJ,MAAOiH,EAAKC,QACZ/G,MAAO,UACP4E,QAASjG,OAAOkG,OAAOzC,KAEzB,MAAMsF,EAAYD,EAAME,iBAAiBb,EAAKnQ,MACxCoQ,EAAUU,EAAMT,WAAWF,EAAKC,SACtCD,EAAK3J,aAAe2J,EAAK3J,aAAazH,QAAQ,0BAA2BqR,GACzED,EAAK5J,eAAiB4J,EAAK5J,eAAexH,QAAQ,wBAAyBgS,MAE7ElK,KAAK7G,KAAO,SACZ6G,KAAKuJ,QAAU,QAGjBE,wBAAwBtQ,GACtB,OAAQA,GACN,QACA,IAAK,SACH,MAAO,sBAET,IAAK,UACH,MAAO,uBAET,IAAK,OACH,MAAO,sBAET,IAAK,QACH,MAAO,qBAET,IAAK,OACH,MAAO,sBAIbsQ,kBAAkBtQ,GAChB,OAAQA,GACN,QACA,IAAK,QACH,MAAO,WAET,IAAK,QACH,MAAO,yCAET,IAAK,KACH,MAAO,iBAKf8Q,EAAMJ,SAAW,UACjBI,EAAMH,SAAW,UACjBG,EAAMG,SAAW,UACjBH,EAAMI,SAAW,UACjBJ,EAAMF,QAAU,EAChBE,EAAMK,QAAU,EAChBL,EAAMM,SAAW,IAAIzH,EAAOA,QAAC,EAAG,EAAG,GACnCmH,EAAMtK,aAAe,gHAOrBsK,EAAMvK,eAAiB,ivBA6BvB,MAAM8K,UAAgB1E,EACpBtG,YAAYuG,GACVhG,MAAMyK,EAAS,CACb9M,KAAM,aACHqI,KAKTyE,EAAQR,QAAU,QAClBQ,EAAQT,QAAU,EAClBS,EAAQC,OAAS,EACjBD,EAAQE,YAAc,EACtBF,EAAQG,QAAU,EAClBH,EAAQI,SAAW,EACnBJ,EAAQ7K,aAAe,8TAUvB6K,EAAQ9K,eAAiB,ghBAoBzB,MAAMmL,UAAiB/E,EACrBtG,YAAYuG,GACVhG,MAAM8K,EAAU,CACdnN,KAAM,cACHqI,IACFuD,IACDA,EAAK1C,OAAO1N,KAAK,CACfmJ,MAAOiH,EAAKwB,KACZtI,MAAO,OACP4E,QAAS,CAAC,IAAK,IAAK,OAEtBkC,EAAK1C,OAAO1N,KAAK,CACfmJ,MAAOiH,EAAKC,QACZ/G,MAAO,UACP4E,QAASjG,OAAOkG,OAAOzC,KAEzB,MAAM2E,EAAUsB,EAASrB,WAAWF,EAAKC,SACzCD,EAAK3J,aAAe2J,EAAK3J,aAAazH,QAAQ,0BAA2BqR,GAAW,SACpFD,EAAK5J,eAAiB4J,EAAK5J,eAAexH,QAAQ,gBAAiBoR,EAAKwB,MAAQ,QAElF9K,KAAK8K,KAAO,IACZ9K,KAAKuJ,QAAU,QAGjBE,kBAAkBtQ,GAChB,OAAQA,GACN,QACA,IAAK,QACH,MAAO,WAET,IAAK,QACH,MAAO,yCAET,IAAK,KACH,MAAO,iBAKf0R,EAAShB,SAAW,QACpBgB,EAASf,SAAW,QACpBe,EAASd,QAAU,EACnBc,EAASE,QAAU,EACnBF,EAASG,OAAS,EAClBH,EAASI,WAAa,EACtBJ,EAASlL,aAAe,6GAOxBkL,EAASnL,eAAiB,mcAoB1B,MAAMwL,UAAepF,EACnBtG,YAAYuG,GACVhG,MAAMmL,EAAQ,CACZxN,KAAM,YACHqI,KAKTmF,EAAOnB,QAAU,EACjBmB,EAAOC,WAAQjL,EACfgL,EAAOvL,aAAe,2OAStBuL,EAAOxL,eAAiB,kbAkBxB,MAAM0L,UAAgBtF,EACpBtG,YAAYuG,GACVhG,MAAMqL,EAAS,CACb1N,KAAM,aACHqI,KAKTqF,EAAQrB,QAAU,EAClBqB,EAAQD,WAAQjL,EAChBkL,EAAQzL,aAAe,qFAOvByL,EAAQ1L,eAAiB,kNAWzB,MAAM2L,UAAiBvF,EACrBtG,YAAYuG,GACVhG,MAAMsL,EAAU,CACd3N,KAAM,cACHqI,IACFuD,IACDA,EAAK1C,OAAO1N,KAAK,CACfmJ,MAAOiH,EAAKnQ,KACZqJ,MAAO,OACP4E,QAASjG,OAAOkG,OAAO/C,KAEzBgF,EAAK1C,OAAO1N,KAAK,CACfmJ,MAAOiH,EAAKC,QACZ/G,MAAO,UACP4E,QAASjG,OAAOkG,OAAOzC,KAEzB,MAAMsF,EAAYmB,EAASlB,iBAAiBb,EAAKnQ,MAC3CoQ,EAAU8B,EAAS7B,WAAWF,EAAKC,SACzCD,EAAKrC,gBAAkBqC,EAAKrC,gBAAgB/O,QAAQ,0BAA2BqR,GAC/ED,EAAKrC,gBAAkBqC,EAAKrC,gBAAgB/O,QAAQ,wBAAyBgS,MAE/ElK,KAAK7G,KAAO,SACZ6G,KAAKuJ,QAAU,QAGjBE,wBAAwBtQ,GACtB,OAAQA,GACN,QACA,IAAK,SACH,MAAO,sBAET,IAAK,UACH,MAAO,uBAET,IAAK,OACH,MAAO,sBAET,IAAK,QACH,MAAO,qBAET,IAAK,OACH,MAAO,sBAIbsQ,kBAAkBtQ,GAChB,OAAQA,GACN,QACA,IAAK,QACH,MAAO,IAET,IAAK,QACH,MAAO,kCAET,IAAK,KACH,MAAO,iBAKfkS,EAASC,WAAa,EACtBD,EAASf,QAAU,EACnBe,EAASd,SAAW,IAAIzH,EAAOA,QAAC,EAAG,EAAG,GACtCuI,EAAS1L,aAAe,6zCA0CxB,MAAM4L,UAAezF,EACnBtG,YAAYuG,GACVhG,MAAMwL,EAAQ,CACZ7N,KAAM,YACHqI,KAKTwF,EAAOxB,QAAU,EACjBwB,EAAOC,YAAc,IAAI1I,EAAOA,QAAC,EAAG,EAAG,GACvCyI,EAAO5L,aAAe,qFAOtB4L,EAAO7L,eAAiB,iZAiBxB,IAuLI+L,EACJ,iyYA2XIC,GACJ,8OASA,MAAMC,WAAsBrM,EAC1BE,aAAYoM,MACVA,EAAKC,MACLA,EAAKC,SACLA,EAAQC,OACRA,EAAMrO,KACNA,KACGqI,GACD,IACFhG,MAAMiF,EAAa8G,GAAY,cAAU5L,OAAWA,OAAWA,EAAW6F,GAC1E/F,KAAKtC,KAAO,gBACZsC,KAAK+L,OAAS,GACd/L,KAAKgM,UAAY,QACjBhM,KAAK6L,MAAQ,EACb7L,KAAK8L,SAAW,QAChB9L,KAAKgM,UAAYJ,GAAS5L,KAAKgM,UAC/BhM,KAAK6L,MAAiB,MAATA,EAAgBA,EAAQ7L,KAAK6L,MAC1C7L,KAAK+L,OAASA,GAAU/L,KAAK+L,OAC7B/L,KAAK8L,SAAWA,GAAY9L,KAAK8L,SACjC9L,KAAKtC,KAAOA,GAAQsC,KAAKtC,KACzBsC,KAAKiM,UAGPC,aACE,IAAIjF,EAAkB,GAClBC,EAAoB,GACpBvH,EAAe,GACfD,EAAiB,GACjBE,EAAW,GAsBf,OArBAI,KAAK+L,OAAO5V,QAAOgW,GAAKA,EAAEhG,UAAS9E,SAAQ8K,IAEzClF,GAAmBkF,EAAElF,gBAAkB,KACvCC,GAAqBiF,EAAEjF,kBAAoB,KAC3CvH,GAAgBwM,EAAExM,aAAe,KACjCD,GAAkByM,EAAEzM,eAAiB,KACrCE,EAAW,IAAKA,KACXuM,EAAEvM,aAGTA,EAAW,IAAKA,EAEZwM,eAAgB,CACd/J,MAAiC,iBAAnBrC,KAAKgM,UAAyB,IAAI9G,EAAMwB,MAAM1G,KAAKgM,WAAWK,sBAAwBrM,KAAKgM,WAE3GM,eAAgB,CACdjK,MAAOrC,KAAK6L,QAIlB7L,KAAKuM,YAAcC,aAAuBtM,IAAfF,KAAK6L,OAAuB7L,KAAK6L,MAAQ,GAC7D,CACLjM,SAAAA,EACAD,aAAc,aACV+L,eACAD,cACAxE,yIAMEtH,uHAMND,eAAgB,aACZgM,eACAD,gtJAEAvE,oMAQExH,wFASVuM,UACE,MAAMrM,SACJA,EAAQF,eACRA,EAAcC,aACdA,GACEK,KAAKkM,aACTnM,MAAMI,OAAOT,EAAgBC,EAAcC,GAG7CsJ,YACE,MAAO,CACL1J,YAAa,gBACbqH,WAAY,CACV+E,MAAO5L,KAAKgM,UACZH,MAAO7L,KAAK6L,MACZnO,KAAMsC,KAAKtC,KACXoO,SAAU9L,KAAK8L,mKCh/CvBW,OAAOC,eAAe,SAAU,CAC/B9F,OAAQ,CACPmF,OAAQ,CACP5S,KAAM,WACNwT,YAAa,+DAEdf,MAAO,CACNzS,KAAM,QACNyT,QAAS,QACTD,YAAa,cAEdd,MAAO,CACNe,QAAS,EACTD,YAAa,SAEdb,SAAU,CACTe,MAAO,CAAC,QAAS,WAAY,OAAQ,QAAS,UAAW,YACzDD,QAAS,QACTD,YAAa,0BAIfG,KAAM,SAAU/U,GACf,MAAMgU,EAAShU,EAAKgU,QAAU/L,KAAK+M,GACnC/M,KAAKgN,eAAiBhN,KAAK+M,GAAGE,QAAQC,QAAQC,SAC9CnN,KAAKoN,SAAW,IAAIzB,GAAc,CACjCC,MAAO,IAAI1G,MAAMwB,MAAM3O,EAAK6T,OAAOS,sBACnCN,OAAQsB,MAAMC,KAAKvB,EAAOwB,UAAUnU,KAAI2T,GAAMA,EAAGS,cAAarX,QAAOgW,KAAOA,IAC5EL,SAAU/T,EAAK+T,YAIjB3L,OAAQ,SAAUpI,GACjBiI,KAAKoN,SAASxB,MAAM9E,IAAI/O,EAAK6T,OAC7B5L,KAAKoN,SAASvB,MAAQ9T,EAAK8T,MAC3B7L,KAAKoN,SAAStB,SAAW/T,EAAK+T,SAC9B9L,KAAKoN,SAASrB,OAAOlR,OAAO,GAC5BmF,KAAKoN,SAASrM,aAAc,KAI9B0L,OAAOgB,kBAAkB,WAAY,CACpCC,SAAU,CACT9B,MAAO,iBACPC,MAAO,iBACPC,SAAU,qBAEX6B,kBAAmB,CAClBP,SAAU,oBAIZ,MAAMQ,GAAgB,CACrB/W,KAAM,CACL+V,QAAS,SACTC,MAAO,CACN,SACA,SACA,MACA,UACA,WACA,SACA,WACA,YACA,UACA,UACA,SACA,aAIF1G,QAAS,CACRyG,SAAS,IAILiB,GAAU,GAChB,IAAK,MAAMC,IAAS,CACnB,QACA,QACA,UACA,WACA,SACA,QACA,SACA,UACA,YACE,CACF,MAAMC,GAAW,IAAIC,GAAOF,IAASlH,OAC/BA,EAAS,GACf,IAAK,MAAMqH,KAAaF,EAAU,CACjC,MAAMG,EAAU/M,OAAOgN,OAAO,GAAIF,IAC7BC,EAAQ7L,OAAS6L,EAAQ9G,UAAS8G,EAAQ7L,MAAQ6L,EAAQ9G,QAAQ,IACvE,IAAIjO,SAAc+U,EAAQ7L,MACb,WAATlJ,IACHA,EAAO+U,EAAQ7L,MAAM7C,YAAY9B,KACpB,YAATvE,IAAoBA,EAAO,QAClB,YAATA,IAAoBA,EAAO,QAClB,YAATA,IAAoBA,EAAO,SAE5B+U,EAAQ1L,MAAM8D,WAAW,WAC5BnN,EAAO,UAEJ+U,EAAQ1L,MAAM4L,SAAS,QAAUF,EAAQ1L,MAAM4L,SAAS,UAC3DjV,EAAO,OAER,MAAMgD,EAAM,CAAEhD,KAAAA,GACV+U,EAAQ7L,QAAOlG,EAAIyQ,QAAUsB,EAAQ7L,OACrC6L,EAAQ9G,UAASjL,EAAI0Q,MAAQqB,EAAQ9G,SACzCR,EAAOsH,EAAQ1L,OAASrG,EAEzB0R,GAAQC,GAASlH,EAGlB,IAAK,MAAOlJ,EAAM2Q,KAAelN,OAAOmN,QAAQT,IAAU,CACzD,MAAMjH,EAASzF,OAAOgN,OAAOhN,OAAOgN,OAAO,GAAIP,IAAgBS,GAC/D5B,OAAO8B,kBAAkB,UAAY7Q,EAAK8Q,cAAe,CACxD5H,OAAAA,EACAkG,OACC,MAAM2B,EAAS,GACTnF,EAAOtJ,KACb,IAAK,MAAO6C,EAAMR,KAAUlB,OAAOmN,QAAQtO,KAAKjI,MAAO,CACtD,IAAI2W,EAAYrM,EACU,UAAtBuE,EAAO/D,GAAM1J,OAChBuV,EAAY,IAAIxJ,MAAMwB,MAAMrE,GAAOgK,uBAEV,QAAtBzF,EAAO/D,GAAM1J,MAChB6G,KAAK+M,GAAGE,QAAQC,QAAQE,SAASuB,YAAYtM,EAAO,CAAEoB,IAAKpB,IAAS,SAAwBuM,GAC3FtF,EAAKyD,GAAGS,YAAY3K,GAAQ+L,EAC5BnC,OAAOoC,MAAMzB,SAAS0B,oBAAoBxF,EAAKyD,GAAI6B,MAGrDH,EAAO5L,GAAQ6L,EAEhB,MAAMZ,EAAQ,IAAIE,GAAOtQ,GAAM+Q,GAC/BzO,KAAK+M,GAAGS,YAAcM,GAEvB3N,OAAO4O,OAIR,MAAMrB,EAAW,GACjB,IAAK,MAAM/G,KAAYxF,OAAOC,KAAKwF,GAClC8G,GAjJgB1T,GAiJE2M,EAjJM3M,GAAI9B,QAAQ,0BAA0B,CAAC8W,EAAGC,KAASA,EAAM,IAAM,IAAMD,EAAER,kBAiJhE,GAAG,UAAY9Q,EAAK8Q,iBAAiB7H,IAErE8F,OAAOgB,kBAAkB,UAAY/P,EAAK8Q,cAAe,CACxDd,SAAAA,EACAC,kBAAmB,CAClB,CAAC,UAAYjQ,EAAK8Q,eAAgB,MAtJpB,IAACxU"}