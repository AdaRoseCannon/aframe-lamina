!function(e){"use strict";function n(e){if(e&&e.__esModule)return e;var n=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var a=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,a.get?a:{enumerable:!0,get:function(){return e[t]}})}})),n.default=e,Object.freeze(n)}var t=n(e),a=["precision","highp","mediump","lowp","attribute","const","uniform","varying","break","continue","do","for","while","if","else","in","out","inout","float","int","uint","void","bool","true","false","discard","return","mat2","mat3","mat4","vec2","vec3","vec4","ivec2","ivec3","ivec4","bvec2","bvec3","bvec4","sampler1D","sampler2D","sampler3D","samplerCube","sampler1DShadow","sampler2DShadow","struct","asm","class","union","enum","typedef","template","this","packed","goto","switch","default","inline","noinline","volatile","public","static","extern","external","interface","long","short","double","half","fixed","unsigned","input","output","hvec2","hvec3","hvec4","dvec2","dvec3","dvec4","fvec2","fvec3","fvec4","sampler2DRect","sampler3DRect","sampler2DRectShadow","sizeof","cast","namespace","using"],o=["<<=",">>=","++","--","<<",">>","<=",">=","==","!=","&&","||","+=","-=","*=","/=","%=","&=","^^","^=","|=","(",")","[","]",".","!","~","*","/","%","+","-","<",">","&","^","|","?",":","=",",",";","{","}"],r=["abs","acos","all","any","asin","atan","ceil","clamp","cos","cross","dFdx","dFdy","degrees","distance","dot","equal","exp","exp2","faceforward","floor","fract","gl_BackColor","gl_BackLightModelProduct","gl_BackLightProduct","gl_BackMaterial","gl_BackSecondaryColor","gl_ClipPlane","gl_ClipVertex","gl_Color","gl_DepthRange","gl_DepthRangeParameters","gl_EyePlaneQ","gl_EyePlaneR","gl_EyePlaneS","gl_EyePlaneT","gl_Fog","gl_FogCoord","gl_FogFragCoord","gl_FogParameters","gl_FragColor","gl_FragCoord","gl_FragData","gl_FragDepth","gl_FragDepthEXT","gl_FrontColor","gl_FrontFacing","gl_FrontLightModelProduct","gl_FrontLightProduct","gl_FrontMaterial","gl_FrontSecondaryColor","gl_LightModel","gl_LightModelParameters","gl_LightModelProducts","gl_LightProducts","gl_LightSource","gl_LightSourceParameters","gl_MaterialParameters","gl_MaxClipPlanes","gl_MaxCombinedTextureImageUnits","gl_MaxDrawBuffers","gl_MaxFragmentUniformComponents","gl_MaxLights","gl_MaxTextureCoords","gl_MaxTextureImageUnits","gl_MaxTextureUnits","gl_MaxVaryingFloats","gl_MaxVertexAttribs","gl_MaxVertexTextureImageUnits","gl_MaxVertexUniformComponents","gl_ModelViewMatrix","gl_ModelViewMatrixInverse","gl_ModelViewMatrixInverseTranspose","gl_ModelViewMatrixTranspose","gl_ModelViewProjectionMatrix","gl_ModelViewProjectionMatrixInverse","gl_ModelViewProjectionMatrixInverseTranspose","gl_ModelViewProjectionMatrixTranspose","gl_MultiTexCoord0","gl_MultiTexCoord1","gl_MultiTexCoord2","gl_MultiTexCoord3","gl_MultiTexCoord4","gl_MultiTexCoord5","gl_MultiTexCoord6","gl_MultiTexCoord7","gl_Normal","gl_NormalMatrix","gl_NormalScale","gl_ObjectPlaneQ","gl_ObjectPlaneR","gl_ObjectPlaneS","gl_ObjectPlaneT","gl_Point","gl_PointCoord","gl_PointParameters","gl_PointSize","gl_Position","gl_ProjectionMatrix","gl_ProjectionMatrixInverse","gl_ProjectionMatrixInverseTranspose","gl_ProjectionMatrixTranspose","gl_SecondaryColor","gl_TexCoord","gl_TextureEnvColor","gl_TextureMatrix","gl_TextureMatrixInverse","gl_TextureMatrixInverseTranspose","gl_TextureMatrixTranspose","gl_Vertex","greaterThan","greaterThanEqual","inversesqrt","length","lessThan","lessThanEqual","log","log2","matrixCompMult","max","min","mix","mod","normalize","not","notEqual","pow","radians","reflect","refract","sign","sin","smoothstep","sqrt","step","tan","texture2D","texture2DLod","texture2DProj","texture2DProjLod","textureCube","textureCubeLod","texture2DLodEXT","texture2DProjLodEXT","textureCubeLodEXT","texture2DGradEXT","texture2DProjGradEXT","textureCubeGradEXT"],i=a.slice().concat(["layout","centroid","smooth","case","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","uvec2","uvec3","uvec4","samplerCubeShadow","sampler2DArray","sampler2DArrayShadow","isampler2D","isampler3D","isamplerCube","isampler2DArray","usampler2D","usampler3D","usamplerCube","usampler2DArray","coherent","restrict","readonly","writeonly","resource","atomic_uint","noperspective","patch","sample","subroutine","common","partition","active","filter","image1D","image2D","image3D","imageCube","iimage1D","iimage2D","iimage3D","iimageCube","uimage1D","uimage2D","uimage3D","uimageCube","image1DArray","image2DArray","iimage1DArray","iimage2DArray","uimage1DArray","uimage2DArray","image1DShadow","image2DShadow","image1DArrayShadow","image2DArrayShadow","imageBuffer","iimageBuffer","uimageBuffer","sampler1DArray","sampler1DArrayShadow","isampler1D","isampler1DArray","usampler1D","usampler1DArray","isampler2DRect","usampler2DRect","samplerBuffer","isamplerBuffer","usamplerBuffer","sampler2DMS","isampler2DMS","usampler2DMS","sampler2DMSArray","isampler2DMSArray","usampler2DMSArray"]),l=r,s=(l=l.slice().filter((function(e){return!/^(gl\_|texture)/.test(e)}))).concat(["gl_VertexID","gl_InstanceID","gl_Position","gl_PointSize","gl_FragCoord","gl_FrontFacing","gl_FragDepth","gl_PointCoord","gl_MaxVertexAttribs","gl_MaxVertexUniformVectors","gl_MaxVertexOutputVectors","gl_MaxFragmentInputVectors","gl_MaxVertexTextureImageUnits","gl_MaxCombinedTextureImageUnits","gl_MaxTextureImageUnits","gl_MaxFragmentUniformVectors","gl_MaxDrawBuffers","gl_MinProgramTexelOffset","gl_MaxProgramTexelOffset","gl_DepthRangeParameters","gl_DepthRange","trunc","round","roundEven","isnan","isinf","floatBitsToInt","floatBitsToUint","intBitsToFloat","uintBitsToFloat","packSnorm2x16","unpackSnorm2x16","packUnorm2x16","unpackUnorm2x16","packHalf2x16","unpackHalf2x16","outerProduct","transpose","determinant","inverse","texture","textureSize","textureProj","textureLod","textureOffset","texelFetch","texelFetchOffset","textureProjOffset","textureLodOffset","textureProjLod","textureProjLodOffset","textureGrad","textureGradOffset","textureProjGrad","textureProjGradOffset"]),c=function(e){var n,t,l,c=0,f=0,p=m,v=[],_=[],g=1,x=0,h=0,y=!1,b=!1,z="",w=r,P=a;"300 es"===(e=e||{}).version&&(w=s,P=i);var M={},S={};for(c=0;c<w.length;c++)M[w[c]]=!0;for(c=0;c<P.length;c++)S[P[c]]=!0;return function(e){return _=[],null!==e?function(e){c=0,e.toString&&(e=e.toString());var t;z+=e.replace(/\r\n/g,"\n"),l=z.length;for(;n=z[c],c<l;){switch(t=c,p){case 0:c=T();break;case 1:c=F();break;case 2:c=$();break;case 3:c=K();break;case 4:c=N();break;case 11:c=E();break;case 5:c=O();break;case d:c=A();break;case 9:c=C();break;case m:c=j()}if(t!==c)if("\n"===z[t])x=0,++g;else++x}return f+=c,z=z.slice(c),_}(e):function(e){v.length&&D(v.join(""));return p=10,D("(eof)"),_}()};function D(e){e.length&&_.push({type:u[p],data:e,position:h,line:g,column:x})}function j(){return v=v.length?[]:v,"/"===t&&"*"===n?(h=f+c-1,p=0,t=n,c+1):"/"===t&&"/"===n?(h=f+c-1,p=1,t=n,c+1):"#"===n?(p=2,h=f+c,c):/\s/.test(n)?(p=9,h=f+c,c):(y=/\d/.test(n),b=/[^\w_]/.test(n),h=f+c,p=y?4:b?3:d,c)}function C(){return/[^\s]/g.test(n)?(D(v.join("")),p=m,c):(v.push(n),t=n,c+1)}function $(){return"\r"!==n&&"\n"!==n||"\\"===t?(v.push(n),t=n,c+1):(D(v.join("")),p=m,c)}function F(){return $()}function T(){return"/"===n&&"*"===t?(v.push(n),D(v.join("")),p=m,c+1):(v.push(n),t=n,c+1)}function K(){if("."===t&&/\d/.test(n))return p=5,c;if("/"===t&&"*"===n)return p=0,c;if("/"===t&&"/"===n)return p=1,c;if("."===n&&v.length){for(;k(v););return p=5,c}if(";"===n||")"===n||"("===n){if(v.length)for(;k(v););return D(n),p=m,c+1}var e=2===v.length&&"="!==n;if(/[\w_\d\s]/.test(n)||e){for(;k(v););return p=m,c}return v.push(n),t=n,c+1}function k(e){for(var n,t,a=0;;){if(n=o.indexOf(e.slice(0,e.length+a).join("")),t=o[n],-1===n){if(a--+e.length>0)continue;t=e.slice(0,1).join("")}return D(t),h+=t.length,(v=v.slice(t.length)).length}}function E(){return/[^a-fA-F0-9]/.test(n)?(D(v.join("")),p=m,c):(v.push(n),t=n,c+1)}function N(){return"."===n||/[eE]/.test(n)?(v.push(n),p=5,t=n,c+1):"x"===n&&1===v.length&&"0"===v[0]?(p=11,v.push(n),t=n,c+1):/[^\d]/.test(n)?(D(v.join("")),p=m,c):(v.push(n),t=n,c+1)}function O(){return"f"===n&&(v.push(n),t=n,c+=1),/[eE]/.test(n)?(v.push(n),t=n,c+1):("-"!==n&&"+"!==n||!/[eE]/.test(t))&&/[^\d]/.test(n)?(D(v.join("")),p=m,c):(v.push(n),t=n,c+1)}function A(){if(/[^\d\w_]/.test(n)){var e=v.join("");return p=S[e]?8:M[e]?7:6,D(v.join("")),p=m,c}return v.push(n),t=n,c+1}},m=999,d=9999,u=["block-comment","line-comment","preprocessor","operator","integer","float","ident","builtin","keyword","whitespace","eof","integer"];var f=function(e,n){var t=c(n),a=[];return a=(a=a.concat(t(e))).concat(t(null))};var p=function(e){for(var n=!1,t=0,a=0;a<e.length;a++)switch(n=n||"keyword"===e[a].type&&"for"===e[a].data,e[a].data){case"(":e[a].depth=n?t++:t;break;case"{":e[a].depth=n?t:t++,n=!1;break;case"}":e[a].depth=--t;break;default:e[a].depth=t}for(a=0;a<e.length;a++){var o=e[a],r=a+1;if(("ident"===o.type||"keyword"===o.type)&&(i(),"ident"===e[r].type&&(i(),r++,"("===e[r].data))){for(;e[r]&&";"!==e[r].data&&"{"!==e[r].data;)e[r++].depth++;e[r]&&"{"===e[r].data&&e[r].depth++}}return e;function i(){for(;e[r]&&("whitespace"===e[r].type||"["===e[r].data||"]"===e[r].data||"integer"===e[r].data);)r++}};var v=function(e){var n=[0],t=n[0],a=0;if(!e||!e.length)return e;if(!("depth"in e[0]))throw new Error("glsl-token-scope: No scope depth defined on tokens! Use glsl-token-depth on these tokens first");for(var o=0;o<e.length;o++){var r=e[o],i=r.depth;i>a?n.push(++t):i<a&&n.splice(-1,1),r.scope=n[n.length-1],r.stack=n.slice(),a=r.depth}return e};var _=function(e){for(var n=0;n<e.length;n++){var t=e[n];if(t.property=!1,"ident"===t.type){for(var a=n;e[--a]&&"whitespace"===e[a].type;);e[a]&&"operator"===e[a].type&&"."===e[a].data&&(t.property=!0)}}return e};var g={"<<=":!0,">>=":!0,"++":!0,"--":!0,"+=":!0,"-=":!0,"*=":!0,"/=":!0,"%=":!0,"&=":!0,"^=":!0,"|=":!0,"=":!0},x={precision:!0,highp:!0,mediump:!0,lowp:!0,attribute:!0,const:!0,uniform:!0,varying:!0,break:!0,continue:!0,do:!0,for:!0,while:!0,if:!0,else:!0,in:!0,out:!0,inout:!0,true:!0,false:!0,return:!0},h=function(e){for(var n=0,t=0;t<e.length;t++){var a=(i=e[t]).type;i.assignment=!1,i.declaration=!1,"ident"!==a&&"builtin"!==a||(n=t+1,l(),"operator"===e[n].type&&g[e[n].data]&&(i.assignment=!0))}for(t=0;t<e.length;t++){var o=e[t],r=(a=o.type,o.data);if(o.declaration=!1,"keyword"===a){if(x[r])continue}else if("ident"!==a)continue;if(n=t+1,s(),"ident"===e[n].type)if(e[n++].declaration=!0,s(),"("!==e[n].data){for(;e[n]&&";"!==e[n].data;)","===e[n].data?(n++,l(),(e[n].declaration="ident"===e[n].type)&&n++):(l(),c(),l(),n++);t=n}else{for(n++,l();e[n]&&")"!==e[n].data&&("keyword"===e[n].type||"ident"===e[n].type);)n++,l(),"ident"===e[n].type&&(e[n++].declaration=!0,l(),s(),l(),","===e[n].data&&(n++,l()));t=n}}for(t=0;t<e.length;t++){var i;if("keyword"===(i=e[t]).type&&("struct"===i.data&&(n=t+1,l(),"ident"===e[n].type&&(n++,l(),"{"===e[n++].data)))){for(l();"ident"===e[n].type||"keyword"===e[n].type;){do{n++,l(),e[n].structMember=!0,e[n].declaration=!1,n++,s()}while(","===e[n].data);";"===e[n].data&&n++,l()}if(n++,l(),"ident"===e[n].type)for(e[n].declaration=!0,l();","===e[++n].data;)l(),n++,l(),"ident"===e[n].type&&(e[n].declaration=!0),l()}}return e;function l(t){for(;e[n]&&"whitespace"===e[n].type;)n++}function s(){for(;e[n]&&("integer"===e[n].type||"["===e[n].data||"]"===e[n].data||"whitespace"===e[n].type);)n++}function c(){if(e[n]&&"("===e[n].data){var t=0;do{if(";"===e[n].data)break;"("===e[n].data&&t++,")"===e[n].data&&t--}while(t&&e[++n])}}};var y=function(e,n){p(e),v(e),_(e),h(e);for(var t=function(e){for(var n={},t=0;t<e.length;t++){var a=e[t];a.declaration&&(n[a.scope]=n[a.scope]||{},n[a.scope][a.data]=a)}return n}(e),a=n||function(){var e=0;return function(n){return n+"_"+(e++).toString(36)}}(),o={},r=0;r<e.length;r++){var i=e[r],l=i.stack,s=i.data;if(i.descoped=!1,"ident"===i.type&&!i.property&&!i.structMember){for(var c=!1,m=l.length-1;m>=0;m--){var d=t[l[m]];if(d&&d[s]){if(c=!0,m)break;i.descoped=i.data,i.data=o[s]=o[s]||a(s,i)||i.data}}c||(i.descoped=i.data,i.data=o[s]=o[s]||a(s,i)||i.data)}}return e};var b=function(e){for(var n=[],t=0;t<e.length;t++)"eof"!==e[t].type&&n.push(e[t].data);return n.join("")};var z=function(e){var n,t,a,o=null,r=null,i=0,l=0,s=0,c=0,m=0,d=[];for(n=0;n<e.length;n++)if("{"===(a=e[n]).data){if(i&&i++)continue;if((t=f(n,w(")"),w()))<0)continue;if(c=t,(t=f(t,w("("),w(")")))<0)continue;if(m=t,(t=f(t,P))<0)continue;if("ident"!==e[t].type)continue;if(r=e[t].data,(t=f(t,P))<0)continue;i=1,l=n,o=e[t].data,s=t;var u=f(t,P);switch(e[u]&&e[u].data){case"lowp":case"highp":case"mediump":s=u}}else if(i&&"}"===a.data){if(--i)continue;d.push({name:r,type:o,body:[l+1,n],args:[m,c+1],outer:[s,n+1]})}for(n=0;n<e.length;n++)if(";"===(a=e[n]).data){if((t=f(n,w(")"),w()))<0)continue;if(c=t,(t=f(t,w("("),w(")")))<0)continue;if(m=t,(t=f(t,P))<0)continue;if("ident"!==e[t].type)continue;if(r=e[t].data,(t=f(t,P))<0)continue;if("operator"===e[t].type)continue;if("return"===e[t].data)continue;o=e[t].data,d.push({name:r,type:o,body:!1,args:[m,c+1],outer:[t,n+1]})}return d.sort((function(e,n){return e.outer[0]-n.outer[0]}));function f(n,t,a){for(var o=n-1;o>=0;o--){if(t(e[o]))return o;if(a&&a(e[o]))return-1}return-1}};function w(e){return function(n){return"operator"===n.type&&(!e||n.data===e)}}function P(e){return"whitespace"!==e.type}var M="csm_Position",S="csm_Emissive",D="csm_Normal",j="csm_PointSize",C="csm_DiffuseColor",$="csm_FragColor";const F={[`${D}`]:{"#include <defaultnormal_vertex>":`\n    vec3 transformedNormal = ${D};\n    #ifdef USE_INSTANCING\n    \t// this is in lieu of a per-instance normal-matrix\n    \t// shear transforms in the instance matrix are not supported\n    \tmat3 m = mat3( instanceMatrix );\n    \ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n    \ttransformedNormal = m * transformedNormal;\n    #endif\n    transformedNormal = normalMatrix * transformedNormal;\n    #ifdef FLIP_SIDED\n    \ttransformedNormal = - transformedNormal;\n    #endif\n    #ifdef USE_TANGENT\n    \tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n    \t#ifdef FLIP_SIDED\n    \t\ttransformedTangent = - transformedTangent;\n    \t#endif\n    #endif\n    `},[`${M}`]:{"#include <project_vertex>":`\n    transformed = ${M};\n    #include <project_vertex>\n  `},[`${j}`]:{"gl_PointSize = size;":`gl_PointSize = ${j};`}},T={[`${C}`]:{"#include <color_fragment>":`\n    #include <color_fragment>\n    diffuseColor = ${C};\n  `},[`${$}`]:{"#include <output_fragment>":`\n    #include <output_fragment>\n    gl_FragColor  = ${$};\n  `},[`${S}`]:{"vec3 totalEmissiveRadiance = emissive;":`\n    vec3 totalEmissiveRadiance = ${S};\n    `}};class K extends e.Material{constructor(e,n,t,a,o){const r=new e(o);super(),this.base=r,this.uniforms=a||{};for(const e in this.base)void 0===this[e]&&(this[e]=0),this[e]=this.base[e];this.update(n,t,a)}update(e,n,t){this.generateMaterial(e,n,t)}generateMaterial(e,n,t){const a=this.parseShader(e),o=this.parseShader(n);this.uniforms=t||{},this.customProgramCacheKey=()=>this.uuid,this.onBeforeCompile=e=>{if(a){const n=this.patchShader(a,e.fragmentShader,T);e.fragmentShader=n}if(o){const n=this.patchShader(o,e.vertexShader,F);e.vertexShader="#define IS_VERTEX;\n"+n}e.uniforms={...e.uniforms,...this.uniforms},this.uniforms=e.uniforms,this.needsUpdate=!0}}patchShader(e,n,t){let a=n;return Object.keys(t).forEach((n=>{Object.keys(t[n]).forEach((o=>{e.main.includes(n)&&(a=k(a,o,t[n][o]))}))})),a=a.replace("void main() {",`\n          ${e.header}\n          void main() {\n            vec3 csm_Position;\n            vec3 csm_Normal;\n            vec3 csm_Emissive;\n\n            #ifdef IS_VERTEX\n              csm_Position = position;\n            #endif\n\n            #ifdef IS_VERTEX\n              csm_Normal = normal;\n            #endif\n            \n            #ifndef IS_VERTEX\n              #ifdef STANDARD\n                csm_Emissive = emissive;\n              #endif\n            #endif\n\n            vec4 csm_DiffuseColor = vec4(1., 0., 0., 1.);\n            vec4 csm_FragColor = vec4(1., 0., 0., 1.);\n            float csm_PointSize = 1.;\n\n            ${e.main}\n          `),a=e.defines+a,a}parseShader(e){if(!e)return;const n={defines:"",header:"",main:""},t=e.match(/void\s*main\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}/g);if(null!=t&&t.length){const a=t[0].match(/\{((.|\n)*?)\}/g);null!=a&&a.length&&(n.main=a[0]);const o=e.replace(t[0],""),r=o.match(/#(.*?;)/g)||[],i=r.reduce(((e,n)=>e.replace(n,"")),o);n.header=i,n.defines=r.join("\n")}return n}}const k=(e,n,t)=>e.split(n).join(t);function E(n){return"string"==typeof n?new e.Color(n):n}function N(e){switch(e){case"alpha":return{min:0,max:1};case"scale":return{min:0};case"map":return{image:void 0};default:return{}}}function O(n){return n instanceof e.Vector3||n instanceof e.Vector2||n instanceof e.Vector4||n instanceof e.Matrix3||n instanceof e.Matrix4}function A(n){return O(n)?n.toArray():n instanceof e.Color?"#"+n.clone().convertLinearToSRGB().getHexString():n instanceof e.Texture?n.image.src:n}const V={normal:"normal",add:"add",subtract:"subtract",multiply:"multiply",lighten:"lighten",darken:"darken",divide:"divide",overlay:"overlay",screen:"screen",softlight:"softlight",negation:"negation",reflect:"reflect"},I={perlin:"perlin",simplex:"simplex",cell:"cell",curl:"curl",white:"white"},L={local:"local",world:"world",uv:"uv"},B={phong:t.MeshPhongMaterial,physical:t.MeshPhysicalMaterial,toon:t.MeshToonMaterial,basic:t.MeshBasicMaterial,lambert:t.MeshLambertMaterial,standard:t.MeshStandardMaterial};class R{constructor(n,t,a){this.uuid=e.MathUtils.generateUUID().replace(/-/g,"_"),this.name="LayerMaterial",this.mode="normal",this.visible=!0;const o=Object.getOwnPropertyNames(n).filter((e=>e.startsWith("u_"))).reduce(((t,a)=>{var o;let r=null==(o=Object.getOwnPropertyDescriptor(n,a))?void 0:o.value;return(O(r)||r instanceof e.Color)&&(r=r.clone()),{...t,[a.slice(1)]:r}}),{});for(const e in o){const n=e.split("_")[1];void 0!==(null==t?void 0:t[n])&&(o[e]=t[n])}t&&Object.keys(t).map((e=>{void 0!==t[e]&&(this[e]=t[e])})),this.uniforms={},this.schema=[];const r={};Object.keys(o).map((e=>{const n=e.split("_")[1];this.uniforms[`u_${this.uuid}_${n}`]={value:E(o[e])},this.schema.push({value:o[e],label:n}),r[n]={set:e=>{this.uniforms[`u_${this.uuid}_${n}`].value=E(e)},get:()=>this.uniforms[`u_${this.uuid}_${n}`].value}})),null!=t&&t.name&&(this.name=t.name),null!=t&&t.mode&&(this.mode=t.mode),null!=t&&t.visible&&(this.visible=t.visible),Object.defineProperties(this,r),this.vertexShader="",this.fragmentShader="",this.vertexVariables="",this.fragmentVariables="",this.onParse=a,this.buildShaders(n),this.schema.push({value:this.mode,label:"mode",options:Object.values(V)}),this.schema.push({value:this.visible,label:"visible"})}buildShaders(e){var n;const t=Object.getOwnPropertyNames(e).filter((e=>"fragmentShader"===e||"vertexShader"===e)).reduce(((n,t)=>{var a;return{...n,[t]:null==(a=Object.getOwnPropertyDescriptor(e,t))?void 0:a.value}}),{}),a={vert:f(t.vertexShader||""),frag:f(t.fragmentShader||"")},o={vert:y(a.vert,this.renameTokens.bind(this)),frag:y(a.frag,this.renameTokens.bind(this))},r={vert:z(o.vert),frag:z(o.frag)},i=r.vert.map((e=>e.name)).indexOf("main"),l=r.frag.map((e=>e.name)).indexOf("main"),s={vert:i>=0?b(o.vert.slice(0,r.vert[i].outer[0])):"",frag:l>=0?b(o.frag.slice(0,r.frag[l].outer[0])):""},c={vert:i>=0?this.getShaderFromIndex(o.vert,r.vert[i].body):"",frag:l>=0?this.getShaderFromIndex(o.frag,r.frag[l].body):""};this.vertexShader=this.processFinal(c.vert,!0),this.fragmentShader=this.processFinal(c.frag),this.vertexVariables=s.vert,this.fragmentVariables=s.frag,null==(n=this.onParse)||n.call(this,this),this.schema=this.schema.filter(((e,n)=>{const t=e.label;return n===this.schema.findIndex((e=>e.label===t))}))}renameTokens(e){if(e.startsWith("u_")){const n=e.slice(2);return`u_${this.uuid}_${n}`}if(e.startsWith("v_")){const n=e.slice(2);return`v_${this.uuid}_${n}`}if(e.startsWith("f_")){const n=e.slice(2);return`f_${this.uuid}_${n}`}return e}processFinal(e,n){const t=e.replace(/\sf_/gm,` f_${this.uuid}_`).replace(/\(f_/gm,`(f_${this.uuid}_`),a=t.match(/^.*return.*$/gm);let o=t.replace(/^.*return.*$/gm,"");if(null!=a&&a[0]){const e=a[0].replace("return","").trim().replace(";",""),t=this.getBlendMode(e,"lamina_finalColor");o+=n?`lamina_finalPosition = ${e};`:`lamina_finalColor = ${t};`}return o}getShaderFromIndex(e,n){return b(e.slice(n[0],n[1]))}getBlendMode(e,n){switch(this.mode){default:case"normal":return`lamina_blend_alpha(${n}, ${e}, ${e}.a)`;case"add":return`lamina_blend_add(${n}, ${e}, ${e}.a)`;case"subtract":return`lamina_blend_subtract(${n}, ${e}, ${e}.a)`;case"multiply":return`lamina_blend_multiply(${n}, ${e}, ${e}.a)`;case"lighten":return`lamina_blend_lighten(${n}, ${e}, ${e}.a)`;case"darken":return`lamina_blend_darken(${n}, ${e}, ${e}.a)`;case"divide":return`lamina_blend_divide(${n}, ${e}, ${e}.a)`;case"overlay":return`lamina_blend_overlay(${n}, ${e}, ${e}.a)`;case"screen":return`lamina_blend_screen(${n}, ${e}, ${e}.a)`;case"softlight":return`lamina_blend_softlight(${n}, ${e}, ${e}.a)`;case"reflect":return`lamina_blend_reflect(${n}, ${e}, ${e}.a)`;case"negation":return`lamina_blend_negation(${n}, ${e}, ${e}.a)`}}getSchema(){return this.schema.map((({label:e,options:n,...t})=>({label:e,options:n,...N(e),...t,value:A(this[e])})))}serialize(){const e=this.constructor.name.split("$")[0];let n=Object.keys(this);n=n.filter((e=>!["uuid","uniforms","schema","fragmentShader","vertexShader","fragmentVariables","vertexVariables","attribs","events","__r3f","onParse"].includes(e)));const t={};n.forEach((e=>{t[e]=this[e]}));const a={};for(const e in this.uniforms){a[e.replace(`u_${this.uuid}_`,"")]=A(this.uniforms[e].value)}return{constructor:e,properties:{...a,...t}}}}class U extends R{constructor(e){super(U,{name:"Depth",...e},(e=>{e.schema.push({value:e.mapping,label:"mapping",options:["vector","world","camera"]});const n=U.getMapping(e.uuid,e.mapping);e.fragmentShader=e.fragmentShader.replace("lamina_mapping_template",n)})),this.mapping="vector"}static getMapping(e,n){switch(n){default:case"vector":return`length(v_${e}_worldPosition - u_${e}_origin)`;case"world":return`length(v_${e}_position - vec3(0.))`;case"camera":return`length(v_${e}_worldPosition - cameraPosition)`}}}U.u_near=2,U.u_far=10,U.u_origin=new e.Vector3(0,0,0),U.u_colorA="white",U.u_colorB="black",U.u_alpha=1,U.vertexShader="\n  varying vec3 v_worldPosition;\n  varying vec3 v_position;\n\n  void main() {\n    v_worldPosition = (vec4(position, 1.0) * modelMatrix).xyz;\n    v_position = position;\n  }\n  ",U.fragmentShader="   \n    uniform float u_alpha;\n    uniform float u_near;\n    uniform float u_far;\n    uniform float u_isVector;\n    uniform vec3 u_origin;\n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n\n    varying vec3 v_worldPosition;\n    varying vec3 v_position;\n\n    void main() {\n      float f_dist = lamina_mapping_template;\n      float f_depth = (f_dist - u_near) / (u_far - u_near);\n\t\t\tvec3 f_depthColor =  mix(u_colorB, u_colorA, 1.0 - clamp(f_depth, 0., 1.));\n  \n  \n      return vec4(f_depthColor, u_alpha);\n    }\n  ";class q extends R{constructor(e){super(q,{name:"Color",...e})}}q.u_color="red",q.u_alpha=1,q.fragmentShader="   \n    uniform vec3 u_color;\n    uniform float u_alpha;\n\n    void main() {\n      return vec4(u_color, u_alpha);\n    }\n  ";class G extends R{constructor(e){super(G,{name:"noise",...e},(e=>{e.schema.push({value:e.type,label:"type",options:Object.values(I)}),e.schema.push({value:e.mapping,label:"mapping",options:Object.values(L)});const n=G.getNoiseFunction(e.type),t=G.getMapping(e.mapping);e.vertexShader=e.vertexShader.replace("lamina_mapping_template",t),e.fragmentShader=e.fragmentShader.replace("lamina_noise_template",n)})),this.type="perlin",this.mapping="local"}static getNoiseFunction(e){switch(e){default:case"perlin":return"lamina_noise_perlin";case"simplex":return"lamina_noise_simplex";case"cell":return"lamina_noise_worley";case"white":return"lamina_noise_white";case"curl":return"lamina_noise_swirl"}}static getMapping(e){switch(e){default:case"local":return"position";case"world":return"(modelMatrix * vec4(position,1.0)).xyz";case"uv":return"vec3(uv, 0.)"}}}G.u_colorA="#666666",G.u_colorB="#666666",G.u_colorC="#FFFFFF",G.u_colorD="#FFFFFF",G.u_alpha=1,G.u_scale=1,G.u_offset=new e.Vector3(0,0,0),G.vertexShader="\n    varying vec3 v_position;\n\n    void main() {\n        v_position = lamina_mapping_template;\n    }\n  ",G.fragmentShader="   \n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n    uniform vec3 u_colorC;\n    uniform vec3 u_colorD;\n    uniform vec3 u_offset;\n\n    uniform float u_alpha;\n    uniform float u_scale;\n\n    varying vec3 v_position;\n\n\n    void main() {\n        float f_n = lamina_noise_template((v_position + u_offset) * u_scale);\n\n        float f_step1 = 0.;\n        float f_step2 = 0.2;\n        float f_step3 = 0.6;\n        float f_step4 = 1.;\n\n        vec3 f_color = mix(u_colorA, u_colorB, smoothstep(f_step1, f_step2, f_n));\n        f_color = mix(f_color, u_colorC, smoothstep(f_step2, f_step3, f_n));\n        f_color = mix(f_color, u_colorD, smoothstep(f_step3, f_step4, f_n));\n\n        return vec4(f_color, u_alpha);\n    }\n  ";class W extends R{constructor(e){super(W,{name:"Fresnel",...e})}}W.u_color="white",W.u_alpha=1,W.u_bias=0,W.u_intensity=1,W.u_power=2,W.u_factor=1,W.vertexShader="\n    varying vec3 v_worldPosition;\n    varying vec3 v_worldNormal;\n\n    void main() {\n        v_worldPosition = vec3(-viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2]);\n        v_worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n        \n    }\n  ",W.fragmentShader="   \n    uniform vec3 u_color;\n    uniform float u_alpha;\n    uniform float u_bias;\n    uniform float u_intensity;\n    uniform float u_power;\n    uniform float u_factor;\n\n    varying vec3 v_worldPosition;\n    varying vec3 v_worldNormal;\n\n    void main() {\n        float f_a = (u_factor  + dot(v_worldPosition, v_worldNormal));\n        float f_fresnel = u_bias + u_intensity * pow(abs(f_a), u_power);\n\n        f_fresnel = clamp(f_fresnel, 0.0, 1.0);\n        return vec4(f_fresnel * u_color, u_alpha);\n    }\n  ";class X extends R{constructor(e){super(X,{name:"Gradient",...e},(e=>{e.schema.push({value:e.axes,label:"axes",options:["x","y","z"]}),e.schema.push({value:e.mapping,label:"mapping",options:Object.values(L)});const n=X.getMapping(e.mapping);e.vertexShader=e.vertexShader.replace("lamina_mapping_template",n||"local"),e.fragmentShader=e.fragmentShader.replace("axes_template",e.axes||"x")})),this.axes="x",this.mapping="local"}static getMapping(e){switch(e){default:case"local":return"position";case"world":return"(modelMatrix * vec4(position,1.0)).xyz";case"uv":return"vec3(uv, 0.)"}}}X.u_colorA="white",X.u_colorB="black",X.u_alpha=1,X.u_start=1,X.u_end=-1,X.u_contrast=1,X.vertexShader="\n\t\tvarying vec3 v_position;\n\n\t\tvod main() {\n      v_position = lamina_mapping_template;\n\t\t}\n  ",X.fragmentShader="   \n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n    uniform vec3 u_axis;\n    uniform float u_alpha;\n    uniform float u_start;\n    uniform float u_end;\n    uniform float u_contrast;\n\n\t\tvarying vec3 v_position;\n\n    void main() {\n\n      float f_step = smoothstep(u_start, u_end, v_position.axes_template * u_contrast);\n      vec3 f_color = mix(u_colorA, u_colorB, f_step);\n\n      return vec4(f_color, u_alpha);\n    }\n  ";class H extends R{constructor(e){super(H,{name:"Matcap",...e})}}H.u_alpha=1,H.u_map=void 0,H.vertexShader="\n    varying vec3 v_position;\n    varying vec3 v_normal;\n    \n    void main() {\n      v_position = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );\n      v_normal = normalize( normalMatrix * normal );\n    }\n    ",H.fragmentShader=" \n\t\tuniform sampler2D u_map;  \n\t\tuniform float u_alpha;  \n\t\tvarying vec3 v_position;\n\t\tvarying vec3 v_normal;\n\n\t\t\n    void main() {\n\t\t\tvec3 f_r = reflect( v_position, v_normal );\n\t\t\tfloat f_m = 2. * sqrt( pow( f_r.x, 2. ) + pow( f_r.y, 2. ) + pow( f_r.z + 1., 2. ) );\n\t\t\tvec2 f_vN = f_r.xy / f_m + .5;\n\n\t\t\tvec3 f_base = texture2D(u_map, f_vN).rgb;\n\n      return vec4(f_base, u_alpha);\n    }\n  ";class Q extends R{constructor(e){super(Q,{name:"Texture",...e})}}Q.u_alpha=1,Q.u_map=void 0,Q.vertexShader="\n    varying vec2 v_uv;\n    \n    void main() {\n        v_uv = uv;\n    }\n    ",Q.fragmentShader=" \n\t\tuniform sampler2D u_map;  \n\t\tuniform float u_alpha;  \n\t\tvarying vec2 v_uv;\n\n    void main() {\n\t\t\tvec3 f_color = texture2D(u_map, v_uv).rgb;\n      return vec4(f_color, u_alpha);\n    }\n  ";class Z extends R{constructor(e){super(Z,{name:"Displace",...e},(e=>{e.schema.push({value:e.type,label:"type",options:Object.values(I)}),e.schema.push({value:e.mapping,label:"mapping",options:Object.values(L)});const n=Z.getNoiseFunction(e.type),t=Z.getMapping(e.mapping);e.vertexVariables=e.vertexVariables.replace("lamina_mapping_template",t),e.vertexVariables=e.vertexVariables.replace("lamina_noise_template",n)})),this.type="perlin",this.mapping="local"}static getNoiseFunction(e){switch(e){default:case"perlin":return"lamina_noise_perlin";case"simplex":return"lamina_noise_simplex";case"cell":return"lamina_noise_worley";case"white":return"lamina_noise_white";case"curl":return"lamina_noise_swirl"}}static getMapping(e){switch(e){default:case"local":return"p";case"world":return"(modelMatrix * vec4(p,1.0)).xyz";case"uv":return"vec3(uv, 0.)"}}}Z.u_strength=1,Z.u_scale=1,Z.u_offset=new e.Vector3(0,0,0),Z.vertexShader="\n       \n      uniform float u_strength;\n      uniform float u_scale;\n      uniform vec3 u_offset;\n\n      vec3 displace(vec3 p) {\n\t\t\t\tvec3 f_position = lamina_mapping_template;\n        float f_n = lamina_noise_template((f_position + u_offset) * u_scale) * u_strength;\n        vec3 f_newPosition = p + (f_n * normal);\n\n\t\t\t\treturn f_newPosition;\n      }\n\n      \n\t\t\tvec3 orthogonal(vec3 v) {\n  \t\t  return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n  \t\t  : vec3(0.0, -v.z, v.y));\n  \t\t}\n  \t\tvec3 recalcNormals(vec3 newPos) {\n  \t\t  float offset = 0.001;\n  \t\t  vec3 tangent = orthogonal(normal);\n  \t\t  vec3 bitangent = normalize(cross(normal, tangent));\n  \t\t  vec3 neighbour1 = position + tangent * offset;\n  \t\t  vec3 neighbour2 = position + bitangent * offset;\n  \t\t  vec3 displacedNeighbour1 = displace(neighbour1);\n  \t\t  vec3 displacedNeighbour2 = displace(neighbour2);\n  \t\t  vec3 displacedTangent = displacedNeighbour1 - newPos;\n  \t\t  vec3 displacedBitangent = displacedNeighbour2 - newPos;\n  \t\t  return normalize(cross(displacedTangent, displacedBitangent));\n  \t\t}\n  \n  \n      void main() {\n       \n\t\t\t\tvec3 f_newPosition = displace(position);\n        lamina_finalNormal = recalcNormals(f_newPosition);\n\n        return f_newPosition;\n      }\n    ";class J extends R{constructor(e){super(J,{name:"Normal",...e})}}J.u_alpha=1,J.u_direction=new e.Vector3(1,1,1),J.vertexShader="   \n  varying vec3 v_normals; \n\n  void main() {\n    v_normals = normal;\n  }\n",J.fragmentShader="   \n  \tuniform float u_alpha;\n  \tuniform vec3 u_color;\n  \tuniform vec3 u_direction;\n\n\t\tvarying vec3 v_normals;\n\n    void main() {\n\t\t\tvec3 f_normalColor = vec3(1.);\n      f_normalColor.x = v_normals.x * u_direction.x;\n      f_normalColor.y = v_normals.y * u_direction.y;\n      f_normalColor.z = v_normals.z * u_direction.z;\n\n      return vec4(f_normalColor, u_alpha);\n    }\n  ";var Y="\n\n// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n// Huge thanks to the creators of these algorithms\n\nfloat lamina_noise_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_perm(vec4 x){return lamina_noise_mod289(((x * 34.0) + 1.0) * x);}\nvec4 lamina_noise_permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 lamina_noise_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n\nfloat lamina_noise_white(vec2 p) {\n  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *\n               (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\nfloat lamina_noise_white(vec3 p) {\n  return lamina_noise_white(p.xy);\n}\n\n\nvec3 lamina_noise_fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\nfloat lamina_noise_perlin(vec3 P) {\n  vec3 Pi0 = floor(P);        // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P);        // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = lamina_noise_permute(lamina_noise_permute(ix) + iy);\n  vec4 ixy0 = lamina_noise_permute(ixy + iz0);\n  vec4 ixy1 = lamina_noise_permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = lamina_noise_fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),\n                 fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return lamina_normalize(2.2 * n_xyz);\n}\n\nfloat lamina_noise_simplex(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n  // Permutations\n  i = mod(i, 289.0);\n  vec4 p = lamina_noise_permute(lamina_noise_permute(lamina_noise_permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +\n                             vec4(0.0, i1.y, i2.y, 1.0)) +\n                    i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  // Gradients\n  // ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0 / 7.0; // N=7\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  // Normalise gradients\n  vec4 norm =\n      lamina_noise_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m =\n      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return lamina_normalize(42.0 *\n         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))));\n}\n\nvec3 lamina_noise_simplex3(vec3 x) {\n  float s = lamina_noise_simplex(vec3(x));\n  float s1 = lamina_noise_simplex(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));\n  float s2 = lamina_noise_simplex(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));\n  vec3 c = vec3(s, s1, s2);\n  return c;\n}\n\nvec3 lamina_noise_curl(vec3 p) {\n  const float e = .1;\n  vec3 dx = vec3(e, 0.0, 0.0);\n  vec3 dy = vec3(0.0, e, 0.0);\n  vec3 dz = vec3(0.0, 0.0, e);\n\n  vec3 p_x0 = lamina_noise_simplex3(p - dx);\n  vec3 p_x1 = lamina_noise_simplex3(p + dx);\n  vec3 p_y0 = lamina_noise_simplex3(p - dy);\n  vec3 p_y1 = lamina_noise_simplex3(p + dy);\n  vec3 p_z0 = lamina_noise_simplex3(p - dz);\n  vec3 p_z1 = lamina_noise_simplex3(p + dz);\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / (2.0 * e);\n  return normalize(vec3(x, y, z) * divisor);\n}\n\nvec3 lamina_permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 lamina_dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\n// From: https://github.com/Erkaman/glsl-worley\nfloat lamina_noise_worley(vec3 P) {\n  float jitter = 1.;\n  bool manhattanDistance = false; \n\n  float K = 0.142857142857; // 1/7\n  float Ko = 0.428571428571; // 1/2-K/2\n  float  K2 = 0.020408163265306; // 1/(7*7)\n  float Kz = 0.166666666667; // 1/6\n  float Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = lamina_permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = lamina_permute(p + Pi.y - 1.0);\n\tvec3 p2 = lamina_permute(p + Pi.y);\n\tvec3 p3 = lamina_permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = lamina_permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = lamina_permute(p1 + Pi.z);\n\tvec3 p13 = lamina_permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = lamina_permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = lamina_permute(p2 + Pi.z);\n\tvec3 p23 = lamina_permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = lamina_permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = lamina_permute(p3 + Pi.z);\n\tvec3 p33 = lamina_permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = lamina_dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 = lamina_dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = lamina_dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = lamina_dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = lamina_dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = lamina_dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = lamina_dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = lamina_dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = lamina_dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\n  vec2 F = sqrt(d11.xy);\n\treturn F.x; // F1, F2\n\n}\n\nfloat lamina_noise_swirl(vec3 position) {\n    float scale = 0.1;\n    float freq = 4. * scale;\n    float t = 1.;\n\n    vec3 pos = (position * scale) + lamina_noise_curl(position * 7. * scale);\n\n    float worley1 = 1. - lamina_noise_worley((pos * (freq * 2.)) +  (t * 2.));\n    float worley2 = 1. - lamina_noise_worley((pos * (freq * 4.)) +  (t * 4.));\n    float worley3 = 1. - lamina_noise_worley((pos * (freq * 8.)) +  (t * 8.));\n    float worley4 = 1. - lamina_noise_worley((pos * (freq * 16.)) +  (t * 16.));\n    \n    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;\n    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;\n    float fbm3 = worley3 * .75 + worley4 * .25;\n\n    vec3 curlWorleyFbm = vec3(fbm1, fbm2, fbm3);\n    float curlWorley = curlWorleyFbm.r * .625 + curlWorleyFbm.g * .25 + \n        curlWorleyFbm.b * .125;\n\n    return curlWorley;\n}\n  \n  \n",ee="\n\nfloat lamina_map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat lamina_normalize(float v) { return lamina_map(v, -1.0, 1.0, 0.0, 1.0); }\n";class ne extends K{constructor({color:e,alpha:n,lighting:t,layers:a,name:o,...r}={}){super(B[t||"basic"],void 0,void 0,void 0,r),this.name="LayerMaterial",this.layers=[],this.baseColor="white",this.alpha=1,this.lighting="basic",this.baseColor=e||this.baseColor,this.alpha=null!=n?n:this.alpha,this.layers=a||this.layers,this.lighting=t||this.lighting,this.name=o||this.name,this.refresh()}genShaders(){let e="",n="",a="",o="",r={};return this.layers.filter((e=>e.visible)).forEach((t=>{e+=t.vertexVariables+"\n",n+=t.fragmentVariables+"\n",a+=t.vertexShader+"\n",o+=t.fragmentShader+"\n",r={...r,...t.uniforms}})),r={...r,u_lamina_color:{value:"string"==typeof this.baseColor?new t.Color(this.baseColor).convertSRGBToLinear():this.baseColor},u_lamina_alpha:{value:this.alpha}},this.transparent=Boolean(void 0!==this.alpha&&this.alpha<1),{uniforms:r,vertexShader:`\n        ${ee}\n        ${Y}\n        ${e}\n\n        void main() {\n          vec3 lamina_finalPosition = position;\n          vec3 lamina_finalNormal = normal;\n\n          ${a}\n\n          csm_Position = lamina_finalPosition;\n          csm_Normal = lamina_finalNormal;\n        }\n        `,fragmentShader:`\n        ${ee}\n        ${Y}\n        \nvec4 lamina_blend_add(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn min(x + y, 1.0) * opacity + x * (1.0 - opacity);\n\n}\nvec3 lamina_blend_alpha(const in vec3 x, const in vec3 y, const in float opacity) {\n\n\treturn y * opacity + x * (1.0 - opacity);\n\n}\n\nvec4 lamina_blend_alpha(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tfloat a = min(y.a, opacity);\n\n\treturn vec4(lamina_blend_alpha(x.rgb, y.rgb, a), max(x.a, a));\n\n}\nvec4 lamina_blend_average(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn (x + y) * 0.5 * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_color_burn(const in float x, const in float y) {\n\n\treturn (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);\n\n}\n\nvec4 lamina_blend_color_burn(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_color_burn(x.r, y.r),\n\t\tlamina_blend_color_burn(x.g, y.g),\n\t\tlamina_blend_color_burn(x.b, y.b),\n\t\tlamina_blend_color_burn(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_color_dodge(const in float x, const in float y) {\n\n\treturn (y == 1.0) ? y : min(x / (1.0 - y), 1.0);\n\n}\n\nvec4 lamina_blend_color_dodge(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_color_dodge(x.r, y.r),\n\t\tlamina_blend_color_dodge(x.g, y.g),\n\t\tlamina_blend_color_dodge(x.b, y.b),\n\t\tlamina_blend_color_dodge(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_darken(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn min(x, y) * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_difference(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn abs(x - y) * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_divide(const in float x, const in float y) {\n\n\treturn (y > 0.0) ? min(x / y, 1.0) : 1.0;\n\n}\n\nvec4 lamina_blend_divide(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_divide(x.r, y.r),\n\t\tlamina_blend_divide(x.g, y.g),\n\t\tlamina_blend_divide(x.b, y.b),\n\t\tlamina_blend_divide(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_exclusion(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn (x + y - 2.0 * x * y) * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_lighten(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn max(x, y) * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_multiply(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn x * y * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_negation(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn (1.0 - abs(1.0 - x - y)) * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_normal(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn y * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_overlay(const in float x, const in float y) {\n\n\treturn (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));\n\n}\n\nvec4 lamina_blend_overlay(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_overlay(x.r, y.r),\n\t\tlamina_blend_overlay(x.g, y.g),\n\t\tlamina_blend_overlay(x.b, y.b),\n\t\tlamina_blend_overlay(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_reflect(const in float x, const in float y) {\n\n\treturn (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);\n\n}\n\nvec4 lamina_blend_reflect(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_reflect(x.r, y.r),\n\t\tlamina_blend_reflect(x.g, y.g),\n\t\tlamina_blend_reflect(x.b, y.b),\n\t\tlamina_blend_reflect(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_screen(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn (1.0 - (1.0 - x) * (1.0 - y)) * opacity + x * (1.0 - opacity);\n\n}\nfloat lamina_blend_softlight(const in float x, const in float y) {\n\n\treturn (y < 0.5) ?\n\t\t(2.0 * x * y + x * x * (1.0 - 2.0 * y)) :\n\t\t(sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));\n\n}\n\nvec4 lamina_blend_softlight(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\tvec4 z = vec4(\n\t\tlamina_blend_softlight(x.r, y.r),\n\t\tlamina_blend_softlight(x.g, y.g),\n\t\tlamina_blend_softlight(x.b, y.b),\n\t\tlamina_blend_softlight(x.a, y.a)\n\t);\n\n\treturn z * opacity + x * (1.0 - opacity);\n\n}\nvec4 lamina_blend_subtract(const in vec4 x, const in vec4 y, const in float opacity) {\n\n\treturn max(x + y - 1.0, 0.0) * opacity + x * (1.0 - opacity);\n\n}\n\n\n        ${n}\n\n        uniform vec3 u_lamina_color;\n        uniform float u_lamina_alpha;\n\n        void main() {\n          vec4 lamina_finalColor = vec4(u_lamina_color, u_lamina_alpha);\n\n          ${o}\n\n          csm_DiffuseColor = lamina_finalColor;\n         \n        }\n        `}}refresh(){const{uniforms:e,fragmentShader:n,vertexShader:t}=this.genShaders();super.update(n,t,e)}serialize(){return{constructor:"LayerMaterial",properties:{color:this.baseColor,alpha:this.alpha,name:this.name,lighting:this.lighting}}}}var te=Object.freeze({__proto__:null,Abstract:R,Color:q,Depth:U,Displace:Z,Fresnel:W,Gradient:X,LayerMaterial:ne,Matcap:H,Noise:G,Normal:J,Texture:Q});AFRAME.registerShader("lamina",{schema:{layers:{type:"selector",description:"Element that contains the layers, defautls to this element."},color:{type:"color",default:"white",description:"Base color"},alpha:{default:1,description:"Alpha"},lighting:{oneOf:["phong","physical","toon","basic","lambert","standard"],default:"basic",description:"Shading model to use."}},init:function(e){const n=e.layers||this.el;this.rendererSystem=this.el.sceneEl.systems.renderer,this.material=new ne({color:new THREE.Color(e.color).convertSRGBToLinear(),layers:Array.from(n.children).map((e=>e.laminaLayer)).filter((e=>!!e)),lighting:e.lighting})},update:function(e){this.material.color.set(e.color),this.material.alpha=e.alpha,this.material.lighting=e.lighting,this.material.layers.splice(0),this.material.needsUpdate=!0}}),AFRAME.registerPrimitive("a-lamina",{mappings:{color:"material.color",alpha:"material.alpha",lighting:"material.lighting"},defaultComponents:{material:"shader:lamina;"}});const ae={mode:{default:"normal",oneOf:["normal","divide","add","overlay","subtract","screen","multiply","softlight","lighten","reflect","darken","negation"]},visible:{default:!0}},oe={};for(const e of["Color","Depth","Fresnel","Gradient","Matcap","Noise","Normal","Texture","Displace"]){const n=(new te[e]).schema,t={};for(const e of n){const n=Object.assign({},e);!n.value&&n.options&&(n.value=n.options[0]);let a=typeof n.value;"object"===a&&(a=n.value.constructor.name,"Vector3"===a&&(a="vec3"),"Vector2"===a&&(a="vec1"),"Matrix4"===a&&(a="mat4")),n.label.startsWith("color")&&(a="color"),(n.label.endsWith("Map")||n.label.endsWith("map"))&&(a="map");const o={type:a};n.value&&(o.default=n.value),n.options&&(o.oneOf=n.options),t[n.label]=o}oe[e]=t}for(const[e,n]of Object.entries(oe)){const t=Object.assign(Object.assign({},ae),n);AFRAME.registerComponent("lamina-"+e.toLowerCase(),{schema:t,init(){const n={},a=this;for(const[e,o]of Object.entries(this.data)){let r=o;"color"===t[e].type&&(r=new THREE.Color(o).convertSRGBToLinear()),"map"===t[e].type&&this.el.sceneEl.systems.material.loadTexture(o,{src:o},(function(n){a.el.laminaLayer[e]=n,AFRAME.utils.material.handleTextureEvents(a.el,n)})),n[e]=r}const o=new te[e](n);this.el.laminaLayer=o},update(e){}});const a={};for(const n of Object.keys(t))a[(re=n,re.replace(/[A-Z]+(?![a-z])|[A-Z]/g,((e,n)=>(n?"-":"")+e.toLowerCase())))]=`${"lamina-"+e.toLowerCase()}.${n}`;AFRAME.registerPrimitive("lamina-"+e.toLowerCase(),{mappings:a,defaultComponents:{["lamina-"+e.toLowerCase()]:""}})}var re}(THREE);
//# sourceMappingURL=aframe-lamina.min.js.map
